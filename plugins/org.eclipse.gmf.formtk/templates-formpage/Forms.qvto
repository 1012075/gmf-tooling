import Context;

modeltype widget uses "http://www.eclipse.org/gmf/2008/Widget";
modeltype context uses "http://www.eclipse.org/gmf/2008/Context";
modeltype binding uses "http://www.eclipse.org/gmf/2008/Binding";
modeltype ecore uses "http://www.eclipse.org/emf/2002/Ecore";

library Forms;

helper context::Context::isBoolean() : Boolean {
	return false
}

helper context::FeatureContext::isBoolean() : Boolean {
	return self.selector.eType.name = 'EBoolean'
}

helper hasReferenceBasedCheckBoxes(s : binding::Section, c : context::Condition) : Boolean {
	return bindingsToRefresh(s, c)->exists(b | b.widget.oclIsKindOf(widget::CheckBox) and not b.selector.isBoolean())
}

helper referenceBasedCheckBoxBindings(s : binding::Section, c : context::Condition) : Sequence(binding::Binding) {
	return bindingsToRefresh(s, c)->select(b | b.widget.oclIsKindOf(widget::CheckBox) and not b.selector.isBoolean())
}

helper getConditionAccessors(e : binding::Section) : Sequence(context::FeatureContext) {
	return (e.bindings->select(b | b.refreshCondition <> null).refreshCondition.accessor->asOrderedSet()->asSequence())[context::FeatureContext]
}

helper needsCast(inputType : ecore::EClass, x : context::FeatureContext) : Boolean {
	return (if x.chain = null then not x.selector.eContainingClass.isSuperTypeOf(inputType) else not x.selector.eContainingClass.isSuperTypeOf(x.chain.oclAsType(context::FeatureContext).selector.oclAsType(ecore::EReference).eReferenceType) endif)
}

helper dependantActions(s : binding::Section, w : widget::Widget) : Sequence(binding::Action) {
	return triggeredConditions(s, associatedBinding(s, w))->collect(c | triggeredActions(s, c))->flatten()
}

helper associatedBinding(s : binding::Section, w : widget::Widget) : binding::Binding {
	return s.bindings->select(b | b.widget = w)->first()
}

helper triggeredActions(s : binding::Section, c : context::Condition) : Sequence(binding::Action) {
	return s.actions->select(a | a.trigger->includes(c))->asSequence()
}

helper triggeredConditions(s : binding::Section, b : binding::Binding) : Sequence(context::Condition) {
	return s.conditions->select(c | c.accessor = b.selector)->asSequence()
}

helper triggeredActions_activated(s : binding::Section, b : binding::Binding) : Sequence(binding::Action) {
	return s.actions->select(a | a.trigger->exists(c | c.accessor = b.selector and b.commitCondition = c))->asSequence()
}

helper triggeredActions_deactivated(s : binding::Section, b : binding::Binding) : Sequence(binding::Action) {
	return s.actions->select(a | a.trigger->exists(c | c.accessor = b.selector and b.commitCondition <> c))->asSequence()
}

helper triggeredBindingToRefreshBesidesTheOne(s : binding::Section, b : binding::Binding) : Sequence(binding::Binding) {
	return let triggeredAndActivatedConditions = s.conditions->select(c | c.accessor = b.selector and b.commitCondition = c) in s.bindings->select(v | v <> b and triggeredAndActivatedConditions->includes(v.refreshCondition))->asSequence()
}

helper dependantBindings(s : binding::Section, w : widget::Widget) : Sequence(binding::Binding) {
	return let activeBinding = associatedBinding(s, w) in let triggered = triggeredConditions(s, activeBinding) in s.bindings->select(b | b <> activeBinding and (triggered->includes(b.refreshCondition) or triggered->includes(b.commitCondition)))->asSequence()
}

helper bindingsToRefresh(s : binding::Section, c : context::Condition) : Sequence(binding::Binding) {
	return s.bindings->select(b | b.refreshCondition = c)->asSequence()
}

helper needsRadioButtonWorkaround(s : binding::Section, c : context::Condition) : Boolean {
	return bindingsToRefresh(s, c)->exists(b | b.widget.oclIsKindOf(widget::RadioButton))
}

helper radioButtonToWorkaround(s : binding::Section, c : context::Condition) : Sequence(binding::Binding) {
	return bindingsToRefresh(s, c)->select(b | b.widget.oclIsKindOf(widget::RadioButton))
}

helper needsCreation(bindings : Sequence(binding::Binding)) : Sequence(context::Context) {
	return ((bindings.selector->select(x | x.needsNullCheck()).chain->asOrderedSet()->asSequence())[context::Context]->collect(it | wholeChain(it))->flatten()->asOrderedSet()->-(bindings.selector->asSet()))[context::Context]->select(x | x.mayBeNull())->asSequence()
}

helper deduceInputType(s : binding::Section) : ecore::EClass {
	return deduceCommon((s.input)[context::FeatureContext].selector.eContainingClass)
}

helper deduceCommon(classes : Sequence(ecore::EClass)) : ecore::EClass {
	return (if classes->asOrderedSet()->size() = 1 then classes->first() else let supertypesOfTheRest = classes->select(c | classes->forAll(cc | c.isSuperTypeOf(cc))) in (if supertypesOfTheRest->isEmpty() then let supertypesOfNone = classes->select(c | classes->forAll(cc | cc <> c and not c.isSuperTypeOf(cc))) in (if supertypesOfNone->isEmpty() then deduceCommon(classes.eSuperTypes) else deduceCommon((supertypesOfNone.eSuperTypes->union(classes->asOrderedSet()->-(supertypesOfNone->asSet())->asSequence())->asOrderedSet()->asSequence())[ecore::EClass]) endif) else mostSpecific(supertypesOfTheRest) endif) endif)
}

helper mostSpecific(classes : Sequence(ecore::EClass)) : ecore::EClass {
	return (if classes->size() = 1 then classes->first() else classes->reject(c | classes->exists(cc | cc <> c and c.isSuperTypeOf(cc)))->first() endif)
}
