	/**
	 * @generated
	 */
	private void installNotationModelRefresher() {
		NotationModelRefresher refresher = getNotationModelRefresher();
		if (refresher.isInstalled()) {
			return;
		}
		<%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%> domainModelEditDomain = <%=importManager.getImportedName("org.eclipse.emf.transaction.util.TransactionUtil")%>.getEditingDomain(<%=_getDiagramCode%>.getElement());
		refresher.install(domainModelEditDomain);
		refreshNotationModel();
	}

	/**
	 * @generated
	 */
	private void uninstallNotationModelRefresher() {
		getNotationModelRefresher().uninstall();
	}

	/**
	 * @generated
	 */
	private NotationModelRefresher notationModelRefresher;

	/**
	 * @generated
	 */
	private NotationModelRefresher getNotationModelRefresher() {
		if (notationModelRefresher == null) {
			notationModelRefresher = new NotationModelRefresher();
		}
		return notationModelRefresher;
	}

	/**
	 * @generated
	 */
	private class NotationModelRefresher extends <%=importManager.getImportedName("org.eclipse.emf.transaction.ResourceSetListenerImpl")%> {
		/**
		 * @generated
		 */
		private <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> filter;
		/**
		 * @generated
		 */
		private <%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%> editingDomain;

		/**
		 * @generated
		 */
		public NotationModelRefresher() {
			createFilter();
		}
<%
boolean hasConstraintsInChildren = false;
for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
	GenNode nextNode = (GenNode) it.next();
	TypeModelFacet typeModelFacet = nextNode.getModelFacet();
	if (typeModelFacet != null && typeModelFacet.getMetaClass() != null && typeModelFacet.getModelElementSelector() != null) {
		hasConstraintsInChildren = true;
		break;
	}
}
%>
<%
if (hasConstraintsInChildren) {
%>

		/**
		 * NB: Children of this element are selected based on constraint declared in <%=genDiagram.getVisualIDRegistryQualifiedClassName()%>. 
		 * Since no assumptions may be made concerning the runtime behavior of the constraint, <b>any</b> non-touch notification may result in 
		 * notational model having to be updated.
		 * <p/>User is encouraged to change implementation of this method to provide an optimization if it is safe to assume that not all notifications
		 * result in such an update.
		 * @generated
		 */
		private <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> getConstrainedChildrenFilter() {
			return <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.NOT_TOUCH;
		}
<%
}
%>

		/**
		 * Creates a notification filter which filters notifications that may possibly affect the notational model
		 * @generated
		 */
		private void createFilter() {
<%
{
	boolean hasDeclaredFilter = false;
	Set genChildFeatures = new LinkedHashSet();
	for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
		GenNode nextNode = (GenNode) it.next();
		TypeModelFacet typeModelFacet = nextNode.getModelFacet();
		if (typeModelFacet == null) {
			continue;
		}
		GenFeature childMetaFeature = typeModelFacet.getChildMetaFeature();
		if (genChildFeatures.contains(childMetaFeature)) {
			continue;
		}
		genChildFeatures.add(childMetaFeature);
		if (!hasDeclaredFilter) {
			hasDeclaredFilter = true;
%>
			filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createFeatureFilter(<%=importManager.getImportedName(childMetaFeature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=childMetaFeature.getFeatureAccessorName()%>());
<%
		} else {
%>
			filter = filter.or(<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createFeatureFilter(<%=importManager.getImportedName(childMetaFeature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=childMetaFeature.getFeatureAccessorName()%>()));
<%
		}
	}	//for
%>
<%
	if (hasDeclaredFilter) {
%>
			filter = filter.and(<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createNotifierFilter(<%=_getSemanticElementCode%>));
<%
	} else {
%>
			filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createNotifierFilter(<%=_getSemanticElementCode%>);
<%
	}
}	//local declaration of hasDeclaredFilter
%>
<%
if (hasConstraintsInChildren) {
%>
			filter = getConstrainedChildrenFilter().or(filter);
<%
}
%>
		}
		/**
		 * @generated
		 */
		public void install(<%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%> editingDomain) {
			if (this.editingDomain != null && !this.editingDomain.equals(editingDomain)) {
				throw new IllegalStateException("Already listening to another editing domain");
			}
			this.editingDomain = editingDomain;
			this.editingDomain.addResourceSetListener(this);
		}

		/**
		 * @generated
		 */
		public boolean isInstalled() {
			return editingDomain != null;
		}

		/**
		 * @generated
		 */
		public void uninstall() {
			if (isInstalled()) {
				editingDomain.removeResourceSetListener(this);
				editingDomain = null;
			}
		}

		/**
		 * @generated
		 */
		public boolean isPrecommitOnly() {
			return true;
		}
		/**
		 * @generated
		 */
		public <%=importManager.getImportedName("org.eclipse.emf.common.command.Command")%> transactionAboutToCommit(<%=importManager.getImportedName("org.eclipse.emf.transaction.ResourceSetChangeEvent")%> event) {
			return getRefreshNotationModelCommand();
		}
		/**
		 * @generated
		 */
		public <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> getFilter() {
			return filter;
		}
	}

	/**
	 * @generated
	 */
	protected void refreshNotationModel() {
		<%=importManager.getImportedName("org.eclipse.emf.common.command.Command")%> command = getRefreshNotationModelCommand();
		if (command == null) {
			return;
		}
		<%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%> domainModelEditDomain = <%=importManager.getImportedName("org.eclipse.emf.transaction.util.TransactionUtil")%>.getEditingDomain(<%=_getDiagramCode%>.getElement());
		getViewer().getEditDomain().getCommandStack().execute(new WrappingCommand(domainModelEditDomain, command));
	}

	/**
	 * @generated
	 */
	private <%=importManager.getImportedName("org.eclipse.emf.common.command.Command")%> getRefreshNotationModelCommand() {
		<%=importManager.getImportedName("java.util.List")%> semanticChildren = getSemanticChildren();
		<%=importManager.getImportedName("java.util.List")%> notationalChildren = <%=_getViewCode%>.getChildren();
		final <%=importManager.getImportedName("java.util.Map")%> semanticToNotational = new <%=importManager.getImportedName("java.util.HashMap")%>();
		for(<%=importManager.getImportedName("java.util.Iterator")%> it = notationalChildren.iterator(); it.hasNext(); ) {
			<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> next = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) it.next();
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> nextSemantic = next.getElement();
			if (nextSemantic != null) {
				semanticToNotational.put(nextSemantic, next);
			}
		}
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> parentView = <%=_getViewCode%>;
		<%=importManager.getImportedName("org.eclipse.emf.common.command.CompoundCommand")%> command = new <%=importManager.getImportedName("org.eclipse.emf.common.command.CompoundCommand")%>();
		for(<%=importManager.getImportedName("java.util.Iterator")%> it = semanticChildren.iterator(); it.hasNext(); ) {
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> next = (<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%>) it.next();
			<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> currentView = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) semanticToNotational.remove(next);
			int nodeVisualID = <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.INSTANCE.getNodeVisualID(parentView, next);
			if (currentView == null) {
				if (shouldCreateView(next)) {
					command.appendIfCanExecute(getCreateNotationalElementCommand(parentView, next, nodeVisualID));
				}
			} else if (nodeVisualID != <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getVisualID(currentView)) {
				<%=importManager.getImportedName(genDiagram.getEditCommandsPackageName() + ".CreateNotationalElementCommand")%> notationalCommand = getCreateNotationalElementCommand(parentView, next, nodeVisualID);
				if (notationalCommand != null) {
					command.appendIfCanExecute(new <%=importManager.getImportedName(genDiagram.getEditCommandsPackageName() + ".ReplaceNotationalElementCommand")%>(parentView, notationalCommand, currentView));
				}
			}
		}
		for(<%=importManager.getImportedName("java.util.Iterator")%> it = semanticToNotational.values().iterator(); it.hasNext(); ) {
			<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> obsoleteView = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) it.next();
			command.appendIfCanExecute(new <%=importManager.getImportedName(genDiagram.getEditCommandsPackageName() + ".RemoveNotationalElementCommand")%>(parentView, obsoleteView));
		}
		return command.getCommandList().isEmpty() ? null : command;
	}

	private <%=importManager.getImportedName(genDiagram.getEditCommandsPackageName() + ".CreateNotationalElementCommand")%> getCreateNotationalElementCommand(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> parentView, <%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> domainElement, int nodeVisualID) {
		switch (nodeVisualID) {
<%
for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
	GenNode nextNode = (GenNode) it.next();
	TypeModelFacet typeModelFacet = nextNode.getModelFacet();
	if (typeModelFacet == null) {
		continue;
	}
	String childNodeInterfaceName = importManager.getImportedName(nextNode.getDomainMetaClass().getQualifiedInterfaceName());
%>
		case <%=importManager.getImportedName(nextNode.getEditPartQualifiedClassName())%>.VISUAL_ID:
			if (domainElement instanceof <%=childNodeInterfaceName%>) {
				return new Create<%=nextNode.getDomainMetaClass().getName()%><%=nextNode.getVisualID()%>NotationCommand(parentView, domainElement<%if (!isListLayout) {%>, new Rectangle(0, 0, 0, 0)<%}%>);
			}
			return null;
<%
}
%>
		default:
			return null;
		}
	}

	/**
	 * @generated
	 */
	private <%=importManager.getImportedName("java.util.List")%> getSemanticChildren() {
<%@ include file="semanticChildren.jetinc" %>
	}

	/**
	 * Returns whether a notational element should be created for the given domain element. 
	 * The generated code always returns <%=genDiagram.isSynchronized()%>. 
	 * User can change implementation of this method to handle a more sophisticated logic.
	 * @generated
	 */
	private boolean shouldCreateView(EObject domainElement) {
		return <%=genDiagram.isSynchronized()%>;
	}
