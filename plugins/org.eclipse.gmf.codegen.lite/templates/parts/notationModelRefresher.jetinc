	/**
	 * @generated
	 */
	private void installNotationModelRefresher() {
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ChildNotationModelRefresher")%> refresher = getNotationModelRefresher();
		if (refresher.isInstalled()) {
			return;
		}
		<%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%> domainModelEditDomain = <%=importManager.getImportedName("org.eclipse.emf.transaction.util.TransactionUtil")%>.getEditingDomain(<%=_getDiagramCode%>.getElement());
		refresher.install(domainModelEditDomain);
		refreshNotationModel();
	}

	/**
	 * @generated
	 */
	private void uninstallNotationModelRefresher() {
		getNotationModelRefresher().uninstall();
	}

	/**
	 * @generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ChildNotationModelRefresher")%> notationModelRefresher;

	/**
	 * @generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ChildNotationModelRefresher")%> getNotationModelRefresher() {
		if (notationModelRefresher == null) {
			notationModelRefresher = new NotationModelRefresher();
		}
		return notationModelRefresher;
	}

	/**
	 * @generated
	 */
	private class NotationModelRefresher extends <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ChildNotationModelRefresher")%> {
<%
boolean hasConstraintsInChildren = false;
for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
	GenNode nextNode = (GenNode) it.next();
	TypeModelFacet typeModelFacet = nextNode.getModelFacet();
	if (typeModelFacet != null && typeModelFacet.getMetaClass() != null && typeModelFacet.getModelElementSelector() != null) {
		hasConstraintsInChildren = true;
		break;
	}
}
%>
<%
if (hasConstraintsInChildren) {
%>

		/**
		 * NB: Children of this element are selected based on constraint declared in <%=genDiagram.getVisualIDRegistryQualifiedClassName()%>. 
		 * Since no assumptions may be made concerning the runtime behavior of the constraint, <b>any</b> non-touch notification may result in 
		 * notational model having to be updated.
		 * <p/>User is encouraged to change implementation of this method to provide an optimization if it is safe to assume that not all notifications
		 * result in such an update.
		 * @generated
		 */
		private <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> getConstrainedChildrenFilter() {
			return <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.NOT_TOUCH;
		}
<%
}
%>

		/**
		 * Creates a notification filter which filters notifications that may possibly affect the notational model
		 * @generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> createFilter() {
<%
{
	boolean hasDeclaredFilter = false;
	Set genChildFeatures = new LinkedHashSet();
	for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
		GenNode nextNode = (GenNode) it.next();
		TypeModelFacet typeModelFacet = nextNode.getModelFacet();
		if (typeModelFacet == null) {
			continue;
		}
		GenFeature childMetaFeature = typeModelFacet.getChildMetaFeature();
		if (genChildFeatures.contains(childMetaFeature)) {
			continue;
		}
		genChildFeatures.add(childMetaFeature);
		if (!hasDeclaredFilter) {
			hasDeclaredFilter = true;
%>
			<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createFeatureFilter(<%=importManager.getImportedName(childMetaFeature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=childMetaFeature.getFeatureAccessorName()%>());
<%
		} else {
%>
			filter = filter.or(<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createFeatureFilter(<%=importManager.getImportedName(childMetaFeature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=childMetaFeature.getFeatureAccessorName()%>()));
<%
		}
	}	//for
%>
<%
	if (hasDeclaredFilter) {
%>
			filter = filter.and(<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createNotifierFilter(<%=_getViewCode%>.getElement()));
<%
	} else {
		hasDeclaredFilter = true;
%>
			<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createNotifierFilter(<%=_getViewCode%>.getElement());
<%
	}
%>
<%
	if (hasConstraintsInChildren) {
		if (hasDeclaredFilter) {
			hasDeclaredFilter = true;
%>
			filter = getConstrainedChildrenFilter().or(filter);
<%
		} else {
%>
			<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> filter = getConstrainedChildrenFilter();
<%
		}
	}
	if (!hasDeclaredFilter) {
%>
			<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.NOT_TOUCH;
<%
	}
%>
			return filter;
<%
}	//local declaration of hasDeclaredFilter
%>
		}

		/**
		 * @generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.commands.CreateNotationalElementCommand")%> getCreateNotationalElementCommand(<%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ElementDescriptor")%> descriptor) {
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> domainElement = descriptor.getElement();
			int nodeVisualID = descriptor.getVisualID();
			switch (nodeVisualID) {
<%
for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
	GenNode nextNode = (GenNode) it.next();
	TypeModelFacet typeModelFacet = nextNode.getModelFacet();
	if (typeModelFacet == null) {
		continue;
	}
	String childNodeInterfaceName = importManager.getImportedName(nextNode.getDomainMetaClass().getQualifiedInterfaceName());
%>
			case <%=importManager.getImportedName(nextNode.getEditPartQualifiedClassName())%>.VISUAL_ID:
				if (domainElement instanceof <%=childNodeInterfaceName%>) {
					return new Create<%=nextNode.getDomainMetaClass().getName()%><%=nextNode.getVisualID()%>NotationCommand(getHost(), domainElement<%if (!isListLayout) {%>, new Rectangle(0, 0, 0, 0)<%}%>);
				}
				return null;
<%
}
%>
			default:
				return null;
			}
		}

		/**
		 * @generated
		 */
		protected <%=importManager.getImportedName("java.util.List")%> getSemanticChildNodes() {
<%@ include file="semanticChildren.jetinc" %>
		}

		/**
		 * Returns whether a notational element should be created for the given domain element. 
		 * The generated code always returns <%=genDiagram.isSynchronized()%>. 
		 * User can change implementation of this method to handle a more sophisticated logic.
		 * @generated
		 */
		protected boolean shouldCreateView(<%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ElementDescriptor")%> descriptor) {
			return <%=genDiagram.isSynchronized()%>;
		}

		/**
		 * @generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> getHost() {
			return <%=_getViewCode%>;
		}
	}

	/**
	 * @generated
	 */
	protected void refreshNotationModel() {
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.AbstractNotationModelRefresher")%> childRefresher = getNotationModelRefresher();
		if (!childRefresher.isInstalled()) {
			return;
		}
		<%=importManager.getImportedName("org.eclipse.emf.common.command.Command")%> command = childRefresher.buildRefreshNotationModelCommand();
		if (command == null) {
			return;
		}
		<%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%> domainModelEditDomain = <%=importManager.getImportedName("org.eclipse.emf.transaction.util.TransactionUtil")%>.getEditingDomain(<%=_getDiagramCode%>.getElement());
		getViewer().getEditDomain().getCommandStack().execute(new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.commands.WrappingCommand")%>(domainModelEditDomain, command));
	}

