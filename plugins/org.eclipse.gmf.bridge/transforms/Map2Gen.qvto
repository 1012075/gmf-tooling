/*
 * Copyright (c) 2009 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
-- import transformations. To be replaced with access keyword, once supported
import Map2GenUtil;
import DiagramRunTimeModel;
import PropertySheet;
import PreferencePages;
import Navigator;
import Actions;
import RichClientPlatformApp;
--import Viewmaps;
import Identity;
--
import gmf.GenModelAccess;
import xpt.XpandFacade;
-- import gmf.IdentifierLibrary;

modeltype GMFMAP uses mappings('http://www.eclipse.org/gmf/2006/mappings');
modeltype GMFTOOL uses tooldef('http://www.eclipse.org/gmf/2005/ToolDefinition');
modeltype GMFGEN uses gmfgen('http://www.eclipse.org/gmf/2009/GenModel');
modeltype GMFGRAPH uses gmfgraph('http://www.eclipse.org/gmf/2006/GraphicalDefinition');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype GENMODEL uses genmodel('http://www.eclipse.org/emf/2002/GenModel');

--
-- Next attempt to author GMFMap-to-GMFGen transformation
--
transformation Map2Gen(in mapModel : GMFMAP, in domainGenModel : GENMODEL, in diagramRuntimeGenModel : GENMODEL, out gmfgenModel : GMFGEN)
access Map2GenUtil;

configuration property rcp : Boolean;
configuration property useMapMode : Boolean;
configuration property useFullRunTime : Boolean;
configuration property useInTransformationCodeGen : Boolean;

property mapRoot : GMFMAP::Mapping = mapModel.rootObjects()![GMFMAP::Mapping];

main() { 
	genModel := domainGenModel.rootObjects()![GENMODEL::GenModel];
	childReferences := mapRoot.getChildReferences();
	
	var genEditor := mapRoot.map structure();
		
	new Identity(mapModel, gmfgenModel).transform();
	
	genEditor.diagram.palette := mapRoot.diagram.map palette();
	genEditor.domainGenModel := mapRoot.diagram.domainModel.findGenPackage().genModel;
	
	genEditor.plugin := mapRoot.map editorPlugin();
	genEditor.editor := object GenEditorView {};
	
	genEditor.diagramUpdater := object GenDiagramUpdater {};
	genEditor.audits := mapRoot.audits.map audits(); -- these two should go before expression providers collection
	genEditor.metrics := mapRoot.metrics.map metrics();
	
	-- FIXME allInstances HACK
	if not GMFGEN::GenParserImplementation.allInstances()->isEmpty() then {
		genEditor.labelParsers := mapRoot.map createGenParsers()
	} endif;
	
--	var xx : GENMODEL := GENMODEL::createEmptyModel().oclAsType(GENMODEL);
--	var notationGenModel@xx : GENMODEL::GenModel := loadNotationGenModel(genEditor.oclAsType(ECORE::EObject));
	new DiagramRunTimeModel(diagramRuntimeGenModel, gmfgenModel).transform();
	
	if not rcp then new Navigator(mapModel, gmfgenModel).transform() endif;
	
	new PropertySheet(mapModel, gmfgenModel).transform();
	new PreferencePages(mapModel, gmfgenModel).transform();
	new Actions(mapModel, gmfgenModel).transform();
	
	if rcp then new RichClientPlatformApp(mapModel, gmfgenModel).transform() endif;
}

-- *************************************************************************************
-- Editor & Diagram
-- *************************************************************************************

mapping GMFMAP::Mapping::structure() : GMFGEN::GenEditorGenerator@gmfgenModel {
	diagram := self.diagram.map structure();
	
	diagram.topLevelNodes += self.nodes->map structure()->asOrderedSet();
	childReferences->forEach(c) { diagram.childNodes += c.map structure(c.child); };
	
	diagram.links := self.links->map structure()->asOrderedSet();
	self.getCompartments()->forEach(e) { diagram.compartments += e.c.map structure(e.n, e.r); };
	
	diagram.getAllNodes()->forEach(n) { setupElementType(n) };
	diagram.links->forEach(l) { setupElementType(l) };
	
	diagram.viewmap := self.diagram.diagramCanvas.map viewmap();
	 
	if self.expressionsByLanguages()->notEmpty() then 
		expressionProviders := self.map createProviderContainer()
	endif;
	
	self.visualIdentity();
}

query GMFMAP::Mapping::expressionsByLanguages(): Sequence(ValueExpression) {
	return GMFMAP::ValueExpression.allInstances()->iterate(it; res: Sequence(ValueExpression) = Sequence{} |
		if res->exists(e | e.language = it.language) then res else res->including(it) endif
	)
} 
mapping GMFMAP::Mapping::createProviderContainer(): GMFGEN::GenExpressionProviderContainer {
	self.expressionsByLanguages()->forEach(e) {
		providers += e.map createExpressionProvider()
	}
}

mapping GMFMAP::CanvasMapping::structure() : GMFGEN::GenDiagram {
	domainDiagramElement := self.domainMetaElement.findGenClass();
	iconProviderPriority := GMFGEN::ProviderPriority::Low;
	validationProviderPriority := GMFGEN::ProviderPriority::Low;
	
	if result.domainDiagramElement.oclIsUndefined() then 
		result.elementType := object GMFGEN::NotationType {}
	else
		result.elementType := result.domainDiagramElement.getOrCreateRuntimeMetamodelType()
	endif;
}

-- *************************************************************************************
-- TopLevelNode
-- *************************************************************************************

mapping GMFMAP::TopNodeReference::structure() : GMFGEN::GenTopLevelNode {
	modelFacet := self.createModelFacet();
	self.child.tool.map paletteEntry().oclAsType(ToolEntry).genNodes += result;
	
	self.child.children->select(e | e.compartment.oclIsUndefined())->forEach(c) {
		var node := c.findProcessableChildReference();
		childNodes += node.map structure(node.child);
	};
	
	labels += self.child.labelMappings->map createNodeLabel(self);
	
	viewmap := self.child.diagramNode.viewmap();
	behaviour += self.child.relatedDiagrams.handleRelatedDiagram(self.child);
}

-- *************************************************************************************
-- GenChildNode
-- *************************************************************************************

mapping GMFMAP::ChildReference::structure(node: GMFMAP::NodeMapping) : GMFGEN::GenChildNode
	disjuncts 
		GMFMAP::ChildReference::createGenChildLabelNode, 
		GMFMAP::ChildReference::createGenChildSideAffixedNode, 
		GMFMAP::ChildReference::createGenChildNode 
{}

mapping GMFMAP::ChildReference::createGenChildLabelNode(node: GMFMAP::NodeMapping) : GMFGEN::GenChildLabelNode 
	when { node.isPureLabelNode() } {
	
	var soleLabel := node.labelMappings->first();
	labelModelFacet := soleLabel.map createLabelModelFacet(self);
	labelReadOnly := soleLabel.readOnly;
	labelElementIcon := soleLabel.diagramLabel.elementIcon;
	viewmap := soleLabel.diagramLabel.viewmap();

	self.child.children[ChildReference]->select(e | e.compartment.oclIsUndefined())->forEach(c) {
		var node := c.findProcessableChildReference();
		childNodes += node.map structure(node.child);
	};
	
	modelFacet := self.createModelFacet();
	
	self.child.tool.map paletteEntry().oclAsType(ToolEntry).genNodes += result;
}
mapping GMFMAP::ChildReference::createGenChildSideAffixedNode(node: GMFMAP::NodeMapping) : GMFGEN::GenChildSideAffixedNode 
	when { node.diagramNode.affixedParentSide <> GMFGRAPH::Direction::NONE} {
	
	viewmap := node.diagramNode.viewmap();
	preferredSideName := node.diagramNode.getAffixedSideAsPositionConstantsName();
	
	labels += node.labelMappings->map createNodeLabel(self);
	
	self.child.children[ChildReference]->select(e | e.compartment.oclIsUndefined())->forEach(c) {
		var node := c.findProcessableChildReference();
		childNodes += node.map structure(node.child);
	};
	
	behaviour += node.relatedDiagrams.handleRelatedDiagram(node);
	modelFacet := self.createModelFacet();
	self.child.tool.map paletteEntry().oclAsType(ToolEntry).genNodes += result;
}
mapping GMFMAP::ChildReference::createGenChildNode(node: GMFMAP::NodeMapping) : GMFGEN::GenChildNode {
	viewmap := node.diagramNode.viewmap();
	
	labels += node.labelMappings->map createNodeLabel(self); 
	
	self.child.children[ChildReference]->select(e | e.compartment.oclIsUndefined())->forEach(c) {
		var node := c.findProcessableChildReference();
		childNodes += node.map structure(node.child);
	};
	
	behaviour += node.relatedDiagrams.handleRelatedDiagram(node);
	modelFacet := self.createModelFacet();
	
	self.child.tool.map paletteEntry().oclAsType(ToolEntry).genNodes += result;
}

-- *************************************************************************************
-- Compartment
-- *************************************************************************************

mapping GMFMAP::CompartmentMapping::structure(_mapping: GMFMAP::NodeMapping, container: GMFMAP::NodeReference): GMFGEN::GenCompartment {
	init {
		result := object GMFGEN::GenCompartment {
			canCollapse := self.compartment.collapsible;
			needsTitle := self.compartment.needsTitle;
			title := self.compartment.name;
			viewmap := self.compartment.viewmap();
		};
	}
	
	if container.oclIsKindOf(GMFMAP::TopNodeReference) then
		container.resolveone(GMFGEN::GenNode).compartments += result
	else {
		var node := container.oclAsType(ChildReference).findProcessableChildReference();
		if not node.oclIsUndefined() then
			node.map structure(node.child).compartments += result
		endif
	} endif;
	
	allChildReferences->select(e | e.compartment = self)->forEach(c) {
		if c.child.children->size() > 0 then
			listLayout := false
		endif;
		var node := c.findProcessableChildReference();
			-- if equivalentChild->hasKey(c) then c else 
			-- equivalentChild->keys()->selectOne(e | equivalentChild->get(e)->includes(c)) endif; 
		childNodes += node.map structure(node.child);	
	}
}

helper GMFMAP::NodeReference::createModelFacet() : GMFGEN::TypeModelFacet {
	if self.child.domainMetaElement.oclIsUndefined() then return null endif;
	var mf := object TypeModelFacet {};
	
	mf.metaClass := self.child.domainMetaElement.findGenClass();
	mf.containmentMetaFeature := self.containmentFeature.findGenFeature();
	
	if self.childrenFeature.oclIsUndefined() then 
		mf.childMetaFeature := mf.containmentMetaFeature 
	else 
		mf.childMetaFeature := self.childrenFeature.findGenFeature() 
	endif;
	
	mf.modelElementSelector := self.child.domainSpecialization.map createConstraint(); 
	mf.modelElementInitializer := self.child.domainInitializer.map structure();
	return mf;
}

-- *************************************************************************************
-- Link
-- *************************************************************************************

mapping GMFMAP::LinkMapping::createModeFacet(): GMFGEN::LinkModelFacet 
	disjuncts 
		GMFMAP::LinkMapping::createFeatureLinkModelFacet,
		GMFMAP::LinkMapping::createTypeLinkModelFacet
	{}

mapping GMFMAP::LinkMapping::createFeatureLinkModelFacet() : GMFGEN::FeatureLinkModelFacet when {
	self.domainMetaElement.oclIsUndefined() and not self.linkMetaFeature.oclIsUndefined()} {
	
	metaFeature := self.linkMetaFeature.findGenFeature();
}
mapping GMFMAP::LinkMapping::createTypeLinkModelFacet() : GMFGEN::TypeLinkModelFacet when {
	not self.domainMetaElement.oclIsUndefined()} {
	
	metaClass := self.domainMetaElement.findGenClass();
	containmentMetaFeature := self.containmentFeature.findGenFeature();
	childMetaFeature := containmentMetaFeature;
	sourceMetaFeature := self.sourceMetaFeature.findGenFeature();
	targetMetaFeature := self.linkMetaFeature.findGenFeature();
	modelElementSelector := self.domainSpecialization.map createConstraint(); -- ALTERNATIVE: if not self.domainSpecialization.oclIsUndefined() then modelElementSelector := self.domainSpecialization.map structure() endif; 
	modelElementInitializer := self.domainInitializer.map structure();
}

mapping GMFMAP::LinkMapping::structure() : GMFGEN::GenLink {
	assert(not self.diagramLink.oclIsUndefined()) with log("link diagram link cannot be null");
	if not self.domainMetaElement.oclIsUndefined() then 
		assert(not self.linkMetaFeature.oclIsUndefined()) with log("linkMetaFeature cannot be null")
	endif;
	
	-- model facet
	if not (self.domainMetaElement.oclIsUndefined() and self.linkMetaFeature.oclIsUndefined()) then 
		modelFacet := self.map createModeFacet()
	endif;
	
	-- labels
	labels += self.labelMappings->map structure(self);
	
	self.tool.map paletteEntry().oclAsType(ToolEntry).genLinks += result;
	-- setupElementType(result);
	result.viewmap := self.diagramLink.viewmap();
	result.creationConstraints := self.creationConstraints.map structure();
}

mapping LabelMapping::structure(link: GMFMAP::LinkMapping): GenLinkLabel {
	readOnly := self.readOnly;
	elementIcon := self.diagramLabel.elementIcon;
	modelFacet := self.map createLabelModelFacet(link);
	var alignmentFacet := self.diagramLabel.findAlignmentFacet();
	if not alignmentFacet.oclIsUndefined() then
		alignment := switch  {
			case (alignmentFacet.alignment = GMFGRAPH::Alignment::BEGINNING) LinkLabelAlignment::SOURCE;
			case (alignmentFacet.alignment = GMFGRAPH::Alignment::CENTER) LinkLabelAlignment::MIDDLE;
			case (alignmentFacet.alignment = GMFGRAPH::Alignment::END) LinkLabelAlignment::TARGET;
			else LinkLabelAlignment::MIDDLE;
		}
	endif;
	viewmap := self.diagramLabel.viewmap();
	viewmap.attributes += object LabelOffsetAttributes {
		var offsetFacet := self.diagramLabel.findOffsetFacet();
		if not offsetFacet.oclIsUndefined()	then {
			x := offsetFacet.x;
			y := offsetFacet.y;
		} else {
			y := (link.labelMappings->indexOf(self) + 1) * 20;
		} endif;
	}
}
query DiagramElement::findOffsetFacet(): LabelOffsetFacet {
	return self.facets->selectOne(e | e.oclIsKindOf(LabelOffsetFacet)).oclAsType(LabelOffsetFacet)
}
query DiagramElement::findAlignmentFacet(): AlignmentFacet {
	return self.facets->selectOne(e | e.oclIsKindOf(AlignmentFacet)).oclAsType(AlignmentFacet)
}
query GMFMAP::NodeMapping::isPureLabelNode() : Boolean {
	return self.labelMappings->size() = 1 and self.children->isEmpty() and self.labelMappings->first().diagramLabel = self.diagramNode;
}
query GMFGRAPH::Node::getAffixedSideAsPositionConstantsName() : String {
	switch {
		case (self.affixedParentSide = GMFGRAPH::Direction::NONE) assert (false) with log('DiagramNode is not side-affixed', self);
		case (self.affixedParentSide = GMFGRAPH::Direction::EAST) return 'EAST';
		case (self.affixedParentSide = GMFGRAPH::Direction::WEST) return 'WEST';
		case (self.affixedParentSide = GMFGRAPH::Direction::NORTH) return 'NORTH';
		case (self.affixedParentSide = GMFGRAPH::Direction::SOUTH) return 'SOUTH';
		case (self.affixedParentSide = GMFGRAPH::Direction::NSEW) return 'NONE'; -- any side
		--else return 'NONE'; -- any side
	};
	return 'NONE'; -- any side
}
helper GMFMAP::CanvasMapping::handleRelatedDiagram(in mapElement : GMFMAP::MappingEntry) : GMFGEN::OpenDiagramBehaviour {
	var rv = object GMFGEN::OpenDiagramBehaviour {};
	-- XXX alternative approach to tell whether related diagram is the same we are processing now, 
	-- originally self.eResource() != mapElement.eResource()
	if self <> mapElement.container() then {
		rv.diagramKind := 'FIXME put GenEditorGenerator.modelID value here';
		rv.editorID := 'FIXME put GenEditorView.id value here';
	} endif;
	return rv;
}

-- *************************************************************************************
-- NodeLabel
-- *************************************************************************************

mapping GMFMAP::LabelMapping::createNodeLabel(node: NodeReference) : GMFGEN::GenNodeLabel {
	init {
		if self.diagramLabel.external then
			result := object GenExternalNodeLabel {}
		else 
			result := object GenNodeLabel {}
		endif
	}
	
	result.modelFacet := self.map createLabelModelFacet(node);
	result.readOnly := self.readOnly;
	result.elementIcon := self.diagramLabel.elementIcon;
	result.viewmap := self.diagramLabel.viewmap();
}

-- XXX perhaps, can replace with mapping WTF::auxParser() and WTF::externalParser, to use QVTO to create instances when
-- neccessary, the problem is finding a proper WTF (labelMapping knows it's MappingEntry, but latter doesn't keep track of CanvasMapping or similar)
property designLabelParser : GMFGEN::ExternalParser = null;
property auxParser : GMFGEN::ExternalParser = null;

-- DGMT#createLabelModelFacet
mapping GMFMAP::LabelMapping::createLabelModelFacet(node: NeedsContainment) : GMFGEN::LabelModelFacet 
	disjuncts 
		GMFMAP::LabelMapping::createDefaultLabelModelFacet,
		GMFMAP::FeatureLabelMapping::createFeatureLabelModelFacet,
		GMFMAP::DesignLabelMapping::createDesignLabelModelFacet,
		GMFMAP::ExpressionLabelMapping::createExpressionLabelModelFacet
	{}
mapping GMFMAP::LabelMapping::createDefaultLabelModelFacet(node: NeedsContainment) : GMFGEN::LabelModelFacet 
	when {self.oclIsTypeOf(LabelMapping)} {
	init {
		if this.auxParser = null then 
			this.auxParser := object GMFGEN::ExternalParser {}
		endif;
	}
	parser := this.auxParser;
}
mapping GMFMAP::FeatureLabelMapping::createFeatureLabelModelFacet(node: NeedsContainment) : GMFGEN::FeatureLabelModelFacet {
--	init {
--		result := object FeatureLabelModelFacet {
			metaFeatures += self.features.findGenFeature();
			editableMetaFeatures += self.editableFeatures.findGenFeature();
			viewPattern := self.viewPattern;
			editPattern := self.editPattern;
			editorPattern := self.editorPattern;
			viewMethod := self.viewMethod.convertLabelTextAccessMethod();
			editMethod := self.editMethod.convertLabelTextAccessMethod();
--		}
--	}
--		var r := object GMFGEN::FeatureLabelModelFacet {};
		-- if exists then select else 
		-- FIXME allInstances == hack
		var p = GMFGEN::PredefinedParser.allInstances()->any(pp | 
			pp.viewMethod = result.oclAsType(FeatureLabelModelFacet).viewMethod and 
			pp.editMethod = result.oclAsType(FeatureLabelModelFacet).editMethod);
		
		if p.oclIsUndefined() then p := object PredefinedParser {
			viewMethod := result.oclAsType(FeatureLabelModelFacet).viewMethod; 
			editMethod := result.oclAsType(FeatureLabelModelFacet).editMethod; 
		} endif;
		parser := p;
--	return r;
}
mapping GMFMAP::DesignLabelMapping::createDesignLabelModelFacet(node: NeedsContainment) : GMFGEN::DesignLabelModelFacet {
--	init {
--		result := object DesignLabelModelFacet {}
--	}
	if this.designLabelParser = null then 
		this.designLabelParser := object GMFGEN::ExternalParser {} 
	endif;
	parser := this.designLabelParser;
	
}
mapping GMFMAP::ExpressionLabelMapping::createExpressionLabelModelFacet(node: NeedsContainment): GMFGEN::ExpressionLabelModelFacet {
--	init {
--		result := object ExpressionLabelModelFacet {
			parser := object ExpressionLabelParser {
				expressionContext := GENMODEL::GenClass.allInstances()->any(e | e.ecoreClass = self.mapEntry.getDomainContext());
				viewExpression := if not self.viewExpression.oclIsUndefined() then self.viewExpression.map createValueExpression() endif;
				editExpression := if not self.editExpression.oclIsUndefined() then self.editExpression.map createValueExpression() endif;
				validateExpression := if not self.validateExpression.oclIsUndefined() then self.validateExpression.map createConstraint() endif;
			};
			
			log('create expression parser', parser) when true;
--		}
--	}
}
mapping GMFMAP::ValueExpression::createValueExpression(): GMFGEN::ValueExpression 
	disjuncts GMFMAP::ValueExpression::createGenValueExpression, GMFMAP::Constraint::createConstraint
{}
mapping GMFMAP::ValueExpression::createGenValueExpression(): GMFGEN::ValueExpression
	when {self.oclIsTypeOf(ValueExpression)}{
		body := self.body;
}
mapping GMFMAP::Constraint::createConstraint(): GMFGEN::GenConstraint {
	body := self.body;
}
mapping GMFMAP::ValueExpression::createExpressionProvider(): GenExpressionProviderBase {
	init {
		switch {
			case (self.language = Language::java) { result := object GenJavaExpressionProvider {} };
			case (self.language = Language::ocl) { result := object GenExpressionInterpreter { language := self.language() } };
			case (self.language = Language::regexp) { result := object GenExpressionInterpreter { language := self.language() } };
			case (self.language = Language::nregexp) { result := object GenExpressionInterpreter { language := self.language() } };
			case (self.language = GenLanguage::_literal) { result := object GenLiteralExpressionProvider {} };
			else { result := object GenExpressionInterpreter {}; }
		};
	}
	
	expressions += ValueExpression.allInstances()->select(e | e.language = self.language)->map createValueExpression();
}
helper GMFMAP::ValueExpression::language(): GenLanguage {
	return switch {
		case (self.language = Language::java) GenLanguage::java;
		case (self.language = Language::ocl)  GenLanguage::ocl;
		case (self.language = Language::regexp) GenLanguage::regexp;
		case (self.language = Language::nregexp) GenLanguage::nregexp;
		case (self.language = Language::_literal) return GenLanguage::_literal;
		else GenLanguage::ocl;
	}
}
query GMFMAP::ValueExpression::selectProvider(): GenExpressionProviderBase {
	return this.mapRoot->resolveone(GMFGEN::GenExpressionProviderContainer).providers->any(e | e.getLanguage() = self.language)
}
query GMFMAP::LabelTextAccessMethod::convertLabelTextAccessMethod() : GMFGEN::LabelTextAccessMethod {
	switch {
		case (self = GMFMAP::LabelTextAccessMethod::NATIVE) return GMFGEN::LabelTextAccessMethod::NATIVE;
		case (self = GMFMAP::LabelTextAccessMethod::REGEXP) return GMFGEN::LabelTextAccessMethod::REGEXP;
		case (self = GMFMAP::LabelTextAccessMethod::PRINTF) return GMFGEN::LabelTextAccessMethod::PRINTF;
		else return GMFGEN::LabelTextAccessMethod::MESSAGE_FORMAT;
	};
	return GMFGEN::LabelTextAccessMethod::MESSAGE_FORMAT;
}

-- *************************************************************************************
-- Constraints and initializers
-- *************************************************************************************

mapping GMFMAP::LinkConstraints::structure() : GMFGEN::GenLinkConstraints {
	sourceEnd := self.sourceEnd.map createConstraint();
	targetEnd := self.targetEnd.map createConstraint();
}

-- note, Constraints may be reused through reuse of NodeMappings, hence need to keep track of the relation
--mapping GMFMAP::Constraint::structure() : GMFGEN::GenConstraint {
--	result._body := self._body;
--	result.bindToProvider(self);
--}
--mapping GMFMAP::ValueExpression::structure_ve() : GMFGEN::ValueExpression { --XXX think about naming, how to avoid conflict with GenConstraint::structure - disjuncts?
--	result._body := self._body;
--	result.bindToProvider(self);
--}
--helper GMFGEN::ValueExpression::bindToProvider(in expression : GMFMAP::ValueExpression) {
--	if expression.language.detectGenLanguage().oclIsUndefined() then return endif; -- XXX perhaps, don't need this line, if .map would give OclInvalid
--	expression.language.detectGenLanguage().map expressionProvider().expressions += self;
--	return;
--}
-- XXX actually, looks like I don't need GenLanguage - I can make most decisions based on 
--query GMFMAP::Language::detectGenLanguage() : GMFGEN::GenLanguage {
--	switch {
--		case (self = GMFMAP::Language::ocl) return GMFGEN::GenLanguage::ocl;
--		case (self = GMFMAP::Language::java) return GMFGEN::GenLanguage::java;
--		case (self = GMFMAP::Language::regexp) return GMFGEN::GenLanguage::regexp;
--		case (self = GMFMAP::Language::nregexp) return GMFGEN::GenLanguage::nregexp;
--		case (self = GMFMAP::Language::_literal) return GMFGEN::GenLanguage::_literal;
--		else { assert (false) with log ('Unknown expression language literal', self); }
--	};
--	return GMFGEN::GenLanguage::ocl;
--}
--mapping GMFGEN::GenLanguage::expressionProvider() : GMFGEN::GenExpressionProviderBase {
--	init {
--		switch {
--			case (self = GMFGEN::GenLanguage::ocl) result := object GMFGEN::GenExpressionInterpreter { language := self };
--			case (self = GMFGEN::GenLanguage::java) result := object GMFGEN::GenJavaExpressionProvider {};
--			case (self = GMFGEN::GenLanguage::regexp) result := object GMFGEN::GenExpressionInterpreter { language := self };
--			case (self = GMFGEN::GenLanguage::nregexp) result := object GMFGEN::GenExpressionInterpreter { language := self };
--			case (self = GMFGEN::GenLanguage::_literal) result := object GMFGEN::GenLiteralExpressionProvider {};
--			else { 
--				assert (false) with log ('Unknown expression language literal', self);
--				-- fake provider with no language set to fail validation (XXX perhaps, makes sense to add 'unrecognized' language?)
--				result := object GMFGEN::GenExpressionInterpreter {};
--			}
--		}
--	}
--}

-- *************************************************************************************
-- ElementInitializer
-- *************************************************************************************

mapping GMFMAP::ElementInitializer::structure() : GMFGEN::GenElementInitializer {
	init {
		assert (false) with log ('No idea how to process ElementInitializer', self);
	}
}

mapping GMFMAP::FeatureSeqInitializer::structure() : GMFGEN::GenElementInitializer {
	init {
		result := object GenFeatureSeqInitializer {
			initializers += self.initializers.map structure();
			if not self.elementClass.oclIsUndefined() then
				elementClass := self.elementClass.findGenClass()
			endif;
		}
	}
}

-- *************************************************************************************
-- GenFeatureInitializer
-- *************************************************************************************

mapping GMFMAP::FeatureInitializer::structure() : GMFGEN::GenFeatureInitializer {
	init {
		assert (false) with log ('No idea how to process FeatureInitializer', self);
	}
}

mapping GMFMAP::FeatureValueSpec::structure() : GMFGEN::GenFeatureInitializer {
	init {
		result := object GenFeatureValueSpec {
			feature := self.feature.findGenFeature();
			value := self.value.map createValueExpression();
		}
	}
}

mapping GMFMAP::ReferenceNewElementSpec::structure() : GMFGEN::GenFeatureInitializer {
	init {
		result := object GenReferenceNewElementSpec {
			feature := self.feature.findGenFeature();
			-- cast to GenFeatureSeqInitializer was in the original DGMT
			newElementInitializers += self.newElementInitializers.map structure().oclAsType(GMFGEN::GenFeatureSeqInitializer);
		}
	}
}

-- *************************************************************************************
-- Palette
-- *************************************************************************************

mapping GMFMAP::CanvasMapping::palette() : GMFGEN::Palette 
	when { not self.palette.oclIsUndefined(); } {
	--if self.palette.oclIsUndefined() return OclInvalid;
	var paletteItems : Sequence(GMFGEN::ToolGroupItem) := self.palette.tools.map paletteEntry();
	var topLevelTools := paletteItems->reject(e | e.oclIsKindOf(GMFGEN::ToolGroup));
	if topLevelTools->notEmpty() then {
		var defaultGroup := object GMFGEN::ToolGroup {
			title := 'Default';
			description := 'Holds top-level non-container tools';
			collapse := false;
			entries += topLevelTools;
		};
		result.groups := result.groups->prepend(defaultGroup);
	} endif;
	
	result.groups += paletteItems[GMFGEN::ToolGroup];
	result.flyout := true;
	if (self.palette._default <> null) then {
		var te := self.palette._default.resolveone(GMFGEN::ToolEntry);
		if te <> null then te._default := true else log ('There\'s default tool specified for palette, but can\'t find gmfgen counterpart') endif;
	} endif;
}

mapping GMFTOOL::AbstractTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		assert (false) with log('Can\'t dispatch paletteEntry() for ', self);
	}
}

mapping GMFTOOL::PaletteSeparator::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		result := object GMFGEN::Separator {};
	}
}

mapping GMFTOOL::CreationTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::ToolEntry {};
		setupCommonToolEntry(self, r);
		result := r;
	}
}

mapping GMFTOOL::GenericTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::ToolEntry {};
		r.qualifiedToolName := self.toolClass;
		setupCommonToolEntry(self, r);
		result := r;
	}
}

mapping GMFTOOL::StandardTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::StandardEntry {};
		switch {
			case (self.toolKind = StandardToolKind::SELECT) r.kind := StandardEntryKind::SELECT;  
			case (self.toolKind = StandardToolKind::MARQUEE) r.kind := StandardEntryKind::MARQUEE;			
			case (self.toolKind = StandardToolKind::ZOOM_PAN) r.kind := StandardEntryKind::ZOOM;			
		};
		setupCommonToolEntry(self, r);
		result := r;
	}
}

mapping GMFTOOL::ToolGroup::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::ToolGroup {};
		r.stack := self.stack;
		r.collapse := self.collapsible;
		setupCommonToolEntry(self, r);
		r.entries += self.tools.map paletteEntry();
		result := r;
	}
}

-- XXX or helper GMFGEN::EntryBase::setupCommonToolEntry()?
helper setupCommonToolEntry(in tool : GMFTOOL::AbstractTool, inout genTool : GMFGEN::EntryBase){
	genTool.title := tool.title;
	genTool.description := tool.description;
	if tool.largeIcon.oclIsTypeOf(GMFTOOL::BundleImage) then 
		genTool.largeIconPath := tool.largeIcon.oclAsType(GMFTOOL::BundleImage).constructIconPath() 
	endif;
	if tool.smallIcon.oclIsTypeOf(GMFTOOL::BundleImage) then 
		genTool.smallIconPath := tool.smallIcon.oclAsType(GMFTOOL::BundleImage).constructIconPath()
	endif;
	return null;
}

-- FIXME process path (makeRelative/makeAbsolute) as in original java code
query GMFTOOL::BundleImage::constructIconPath() : String {
	if self.path.oclIsUndefined() or self.path.trim().size() = 0 then return null endif;
	if self.bundle.oclIsUndefined() or self.bundle.trim().size() = 0 then 
		return self.path.makeRelative() 
	endif;
	return self.bundle.makeAbsolute() + self.path;
}
query String::makeRelative(): String {
	return self;
}
query String::makeAbsolute(): String {
	return if self.startsWith('/') or self->exists(e | e = ':') then self + '/' else '/' + self + '/' endif;
}

-- *************************************************************************************
-- Audits
-- *************************************************************************************
mapping GMFMAP::AuditContainer::audits() : GMFGEN::GenAuditRoot {
	result.categories += self.allContainers().map category();
	result.rules += self.allContainers().audits.map rule();
	
	var allRulesWithContext := result.rules->select(not target.oclIsUndefined());
	var rulesWithDiagramElementTarget := allRulesWithContext->select(target.oclIsTypeOf(GMFGEN::GenDiagramElementTarget));
	rulesWithDiagramElementTarget.target[GMFGEN::GenDiagramElementTarget]->forEach(t) {
		-- Basically, all rules with targets != null
		-- get a context (emf.validation), which is a scope or set of elements audit is evaluated against.
		-- For certain cases, e.g. diagram elements as audit targets, special logic to select these
		-- elements should get generated - to filter diagram views by visualID, and hence
		-- there's another implementation of IClientSelector and dedicated context.
		var ctx : GMFGEN::GenAuditContext;
		-- use of exists seems to be sufficient, as all ruleTargets for a given context should get same elements
		-- by the nature of construction. However, more honest way would be to use forAll, accompanied with not isEmpty():
		-- not cc.ruleTargets[GMFGEN::GenDiagramElementTarget]->isEmpty() and cc.ruleTargets[...]->forAll(element = t.element) 
		ctx := result.clientContexts->selectOne(cc | cc.ruleTargets[GMFGEN::GenDiagramElementTarget]->exists(element = t.element));
		-- there might be already a context to pick same elements this target has 
		if ctx.oclIsUndefined() then {
			ctx := object GMFGEN::GenAuditContext {
				id := t.element.visualID.repr()->asList()->joinfields('_','Ctx_','')
			};
			result.clientContexts += ctx;
		} endif;
		t.contextSelector := ctx;
	};
	var defaultAuditContext := object GMFGEN::GenAuditContext {};
	result.clientContexts += defaultAuditContext;
	(allRulesWithContext - rulesWithDiagramElementTarget).target->forEach(t) { t.contextSelector := defaultAuditContext };
	
}
query GMFMAP::AuditContainer::allContainers() : Sequence(GMFMAP::AuditContainer) {
	var nested := self.childContainers.allContainers()->flatten();
	return nested->prepend(self);
}
mapping GMFMAP::AuditContainer::category() : GMFGEN::GenAuditContainer {
	id := self.id;
	name := self.name;
	description := self.description;
	path += self.parentContainer.resolveone(GMFGEN::GenAuditContainer).path;
	-- alternative, not sure which one is better: 
	-- path += self.parentContainer.map category().path;
	path += result;
}
mapping GMFMAP::AuditRule::rule() : GMFGEN::GenAuditRule {
	id := self.id;
	name := self.name;
	message := self.message;
	description := self.description;
	useInLiveMode := self.useInLiveMode;
	target := self.target.map auditTarget();
	rule := self.rule.map createConstraint();
	severity := self.severity.severity();
	category := self.container.map category();
}
mapping GMFMAP::Auditable::auditTarget() : GMFGEN::GenAuditable  
	disjuncts GMFMAP::DomainElementTarget::ruleTarget, GMFMAP::NotationElementTarget::ruleTarget, GMFMAP::DiagramElementTarget::ruleTarget,
		GMFMAP::AuditedMetricTarget::ruleTarget, GMFMAP::DomainAttributeTarget::ruleTarget
	{} --assert (false) with log ('Unknown rule target', self);
mapping GMFMAP::DomainElementTarget::ruleTarget() : GMFGEN::GenDomainElementTarget {
	element := self.element.findGenClass();
}
mapping GMFMAP::NotationElementTarget::ruleTarget() : GMFGEN::GenNotationElementTarget {
	element := self.element.findGenClass(); -- XXX double-check if domain's genmodel should be consulted here, not notation's
}
mapping GMFMAP::DiagramElementTarget::ruleTarget() : GMFGEN::GenDiagramElementTarget {
	-- alternatives:
	if self.element.oclIsKindOf(LinkMapping) then {
		element += self.element.oclAsType(LinkMapping).map structure();
	} else if self.element.oclIsKindOf(NodeMapping) then {
		var el := self.element.container();
		if el.oclIsKindOf(TopNodeReference) then
			element += el.oclAsType(TopNodeReference).map structure()
		else
			element += el.oclAsType(ChildReference).map structure(self.element.oclAsType(NodeMapping)) 
		endif
	} endif
	endif;
--	element += self.element.resolveIn(GMFMAP::NodeMapping::structure, GMFGEN::GenCommonBase);
--	element += self.element.resolveIn(GMFMAP::LinkMapping::structure, GMFGEN::GenCommonBase);
--	element += self.element.resolveIn(GMFMAP::TopNodeReference::structure, GMFGEN::GenCommonBase);
--	element += self.element.resolve(GMFGEN::GenCommonBase);
}
mapping GMFMAP::AuditedMetricTarget::ruleTarget() : GMFGEN::GenAuditedMetricTarget {
	result.metric := self.metric.map rule();
	var resultClassifier := loadEcoreGenModel().genPackages->first().genClassifiers[GENMODEL::GenDataType]->selectOne(ecoreDataType.name='EDoubleObject');
	assert (not resultClassifier.oclIsUndefined()) with log ('Troubles loading ecore.genmodel and accessing EDoubleObject');
	result.metricValueContext := resultClassifier;
}
mapping GMFMAP::DomainAttributeTarget::ruleTarget() : GMFGEN::GenDomainAttributeTarget {
	attribute := self.attribute.findGenFeature();
	nullAsError := self.nullAsError;
}

query GMFMAP::Severity::severity() : GMFGEN::GenSeverity {
	switch  {
		case (self = GMFMAP::Severity::INFO) return GMFGEN::GenSeverity::INFO;
		case (self = GMFMAP::Severity::WARNING) return GMFGEN::GenSeverity::WARNING;
		case (self = GMFMAP::Severity::ERROR) return GMFGEN::GenSeverity::ERROR;
	};
	assert (false) with log ('Unrecognized Severity::* value', self);
	return null;
}

-- *************************************************************************************
-- Metrics
-- *************************************************************************************
mapping GMFMAP::MetricContainer::metrics() : GMFGEN::GenMetricContainer {
	metrics += self.metrics.map rule();
}
mapping GMFMAP::MetricRule::rule() : GMFGEN::GenMetricRule {
	key := self.key;
	name := self.name;
	description := self.description;
	lowLimit := self.lowLimit;
	highLimit := self.highLimit;
	rule := self.rule.map createValueExpression();
	target := self.target.map metricTarget();
}
mapping GMFMAP::Measurable::metricTarget() : GMFGEN::GenMeasurable
	disjuncts GMFMAP::DomainElementTarget::ruleTarget, GMFMAP::NotationElementTarget::ruleTarget, GMFMAP::DiagramElementTarget::ruleTarget
	{} --assert (false) with log ('Unknown rule target', self);
	
-- *************************************************************************************
-- Viewmaps
-- *************************************************************************************

property templateRoots : Sequence(String) = Sequence {'platform:/plugin/org.eclipse.gmf.graphdef.codegen/templates/'};

mapping GMFGRAPH::Canvas::viewmap() : GMFGEN::Viewmap {
	init {
		result := object GMFGEN::FigureViewmap {
			figureQualifiedClassName := 'org.eclipse.draw2d.FreeformLayer';
		};
	}
}
helper GMFGRAPH::Node::viewmap() : GMFGEN::Viewmap {
	var rv : GMFGEN::Viewmap;
	
	if useInTransformationCodeGen then {
		rv := self.figure.viewmap();
		rv.layoutType := self.getLayoutType();
		rv.attributes += if self.hasResizeConstraints() then self.map resizeConstraints() endif;
		rv.attributes += if self.hasDefaultSize() then self.map defaultSize() endif;
	} else {
		rv := object GMFGEN::ModeledViewmap {
			figureModel := self.oclAsType(EObject);
		}
	} endif;
	
	return rv;
}
query GMFGRAPH::Node::hasResizeConstraints(): Boolean {
	return not (self.resizeConstraint.oclIsUndefined() or (self.resizeConstraint = Direction::NSEW))
}
query GMFGRAPH::Node::hasDefaultSize(): Boolean {
	var facet : DefaultSizeFacet := self.facets[DefaultSizeFacet]->first();
	var defaultSize := if facet.oclIsUndefined() then self.figure.actualFigure.preferredSize else facet.defaultSize endif;
	
	return not defaultSize.oclIsUndefined()
}
mapping GMFGRAPH::Node::resizeConstraints(): GMFGEN::ResizeConstraints {
	resizeHandles := self.resizeConstraint.repr().toInteger();
}
mapping GMFGRAPH::Node::defaultSize(): GMFGEN::DefaultSizeAttributes {
	var facet : DefaultSizeFacet := self.facets[DefaultSizeFacet]->first();
	var defaultSize := if facet.oclIsUndefined() then self.figure.actualFigure.preferredSize else facet.defaultSize endif;
	
	if not defaultSize.oclIsUndefined() then {
		height := defaultSize.dy;
		width := defaultSize.dx;
	} endif;
}
query GMFGRAPH::Node::getLayoutType(): GMFGEN::ViewmapLayoutType {
	var layout = ViewmapLayoutType::UNKNOWN;
	if (self.figure.actualFigure.layout.oclIsUndefined()) then {
		layout := GMFGEN::ViewmapLayoutType::UNKNOWN;
	} else {
		if self.figure.actualFigure.layout.oclIsKindOf(GMFGRAPH::FlowLayout) then {
			var fl := self.figure.actualFigure.layout.oclAsType(GMFGRAPH::FlowLayout);
			if fl.forceSingleLine then 
				layout := GMFGEN::ViewmapLayoutType::TOOLBAR_LAYOUT 
			else
				layout := GMFGEN::ViewmapLayoutType::FLOW_LAYOUT 
			endif;
		} else 
			if self.figure.actualFigure.layout.oclIsKindOf(GMFGRAPH::XYLayout) then 
				layout := GMFGEN::ViewmapLayoutType::XY_LAYOUT 
			endif
		endif;
	} endif;
	return layout;
}
helper GMFGRAPH::Compartment::viewmap() : GMFGEN::Viewmap {
	if self.figure.oclIsUndefined() then
		return object GMFGEN::FigureViewmap {}
	endif;
	-- FIXME check self.accessor, see InnerClassViewapProducer
	if self.accessor.oclIsUndefined() then 
		return self.figure.viewmap() 
	endif;
	return self.figure.viewmap(self.accessor);
}
helper GMFGRAPH::Connection::viewmap() : GMFGEN::Viewmap {
	if self.figure.oclIsUndefined() then
		return object GMFGEN::FigureViewmap {
			figureQualifiedClassName := "org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx";		
		}
	endif;
	return self.figure.viewmap();
}
helper GMFGRAPH::DiagramLabel::viewmap() : GMFGEN::Viewmap {
	if self.figure.oclIsUndefined() then
		return object GMFGEN::FigureViewmap {
			figureQualifiedClassName := "org.eclipse.draw2d.Label"
		}
	endif;
	
	if self.accessor.oclIsUndefined() then 
		return self.figure.viewmap()
	endif;
	
	-- for GenLinkLabel, need to specify alignment based on AlignmentFacet
	-- besides, need to create LabelOffsetAttributes and optionally populate it from LabelOffsetFacet
	return self.figure.viewmap(self.accessor);
}

helper GMFGRAPH::FigureDescriptor::viewmap() : GMFGEN::Viewmap {
	var rs: GMFGEN::Viewmap := null;
	
	if self.actualFigure.isBareInstance() then { 
		rs := object GMFGEN::FigureViewmap {
			figureQualifiedClassName := self.actualFigure.xpand('Runtime::fqn', templateRoots);
		}
	} else {
		rs := object GMFGEN::InnerClassViewmap { 
			classBody := self.xpand('top::Descriptor::Inner', templateRoots);
			className := self.name.firstToUpper(); -- FIXME InnerClassViewmapProducer has validJavaIdentifier(capName())
		};
	} endif;
	
	rs.attributes := self.actualFigure.createStyleAttributes();
	
	return rs;
}

helper GMFGRAPH::Figure::createStyleAttributes() : GMFGEN::StyleAttributes {
	var attributes: GMFGEN::StyleAttributes;
	if not (self.font.oclIsUndefined() and self.foregroundColor.oclIsUndefined() and 
		self.backgroundColor.oclIsUndefined()) then {
			attributes := object GMFGEN::StyleAttributes {
				fixedFont := if (self.font.oclIsUndefined()) then false else true endif;
				fixedForeground := if (self.foregroundColor.oclIsUndefined()) then false else true endif;
				fixedBackground := if (self.backgroundColor.oclIsUndefined()) then false else true endif;
			};
	} endif;
	return attributes;
}

helper GMFGRAPH::FigureDescriptor::viewmap(childAccess : GMFGRAPH::ChildAccess) : GMFGEN::Viewmap {
	return
	if useInTransformationCodeGen then
		object GMFGEN::ParentAssignedViewmap {
			getterName := childAccess.accessor;
			figureQualifiedClassName := childAccess.figure.xpand('Runtime::fqn', templateRoots);
			attributes := childAccess.figure.createStyleAttributes();
		}
	else object GMFGEN::ModeledViewmap {
		figureModel := self.oclAsType(EObject);
	} endif;
}
query GMFGRAPH::Figure::isBareInstance() : Boolean { return false; }
query GMFGRAPH::RealFigure::isBareInstance() : Boolean {
	if self.children->notEmpty() then return false endif;
	if self.oclIsKindOf(GMFGRAPH::Label) then {
		if self.oclAsType(GMFGRAPH::Label).text <> null then return false endif;
	} endif;
	if self.oclIsKindOf(GMFGRAPH::Shape) then {
		var sh : Shape := self.oclAsType(GMFGRAPH::Shape);
		if sh.lineWidth <> 1 then return false endif;
		if sh.lineKind <> LineKind::LINE_SOLID then return false endif;
		if not sh.outline or not sh.fill or sh.xorFill or sh.xorOutline then return false endif;
	} endif;
	
	if self.border <> null then return false endif;
	if self.font <> null then return false endif;
	if self.foregroundColor <> null then return false endif;
	if self.backgroundColor <> null then return false endif;
	if self.maximumSize <> null then return false endif;
	if self.minimumSize <> null then return false endif;
	if self.preferredSize <> null then return false endif;
	if self.insets <> null then return false endif;
	if self.location <> null then return false endif;
	if self.size <> null then return false endif;
	
	if self.oclIsKindOf(GMFGRAPH::PolylineConnection) then {
		if self.oclAsType(GMFGRAPH::PolylineConnection).sourceDecoration <> null then return false endif;
		if self.oclAsType(GMFGRAPH::PolylineConnection).targetDecoration <> null then return false endif;
	} endif;
	
	if self.oclIsKindOf(GMFGRAPH::SVGFigure) then {
		if self.oclAsType(GMFGRAPH::SVGFigure).documentURI <> null then return false endif;
	} endif;
	return true;
}

-- *************************************************************************************
-- Parsers
-- *************************************************************************************

mapping GMFMAP::Mapping::createGenParsers(): GenParsers {
--	object GenParsers {
			implementations += GMFGEN::GenParserImplementation.allInstances();
			if this.designLabelParser <> null then implementations += this.designLabelParser endif;
			if this.auxParser <> null then implementations += this.auxParser endif;
			extensibleViaService := true;
--		};
}

-- *************************************************************************************
-- Editor Plugin
-- *************************************************************************************

mapping GMFMAP::Mapping::editorPlugin() : GMFGEN::GenPlugin {
	requiredPlugins := Set{'org.eclipse.draw2d'};
	
	if self.links->notEmpty() or GMFMAP::LabelMapping.allInstances()->notEmpty() then
		requiredPlugins += 'org.eclipse.gmf.runtime.draw2d.ui'
	endif;
	
	self.diagram.diagramCanvas.figures->forEach(fg) {
		if not fg.implementationBundle.oclIsUndefined() then {
			result.requiredPlugins += fg.implementationBundle
		} endif;
	}
}

-- *************************************************************************************
-- Visual Identity
-- *************************************************************************************

property labelNodes: Sequence(LabelMapping) = Sequence{};

helper GMFMAP::Mapping::visualIdentity() {
	self.diagram.resolveone(GenDiagram).visualID := 1000;
	
	self.nodes->collect(e |
		if e.resolveone(GenTopLevelNode).visualID = 0 then {
		 	e.resolveone(GenTopLevelNode).visualID := topNodeID();
			e.child.children->collect(visualIdentity());
			e.child.labelMappings->collect(visualIdentity(e));
		} endif
	);
	
	self.links->collect(visualIdentity());
		
	self.getCompartments()->collect(e | e.c.visualIdentity(e.n, e.r));
	
	return null;
}

helper GMFMAP::ChildReference::visualIdentity() {
	var node := self.findProcessableChildReference();
	if not node.oclIsUndefined() then
		if node.map structure(node.child).visualID = 0 then {
			if not node.referencedChild.oclIsUndefined() then
				node.map structure(node.child).visualID := childNodeID()
			else {	
				node.map structure(node.child).visualID := childNodeID();
				node.child.children->collect(e |
					if e.needVisualID() then e.visualIdentity() endif
				);
			} endif;
			node.map structure(node.child).labels->collect(e | visualIdentity(e));
			-- node.child.labelMappings->collect(visualIdentity(node));
		} endif
	endif
}

query ChildReference::needVisualID(): Boolean {
	var node := self.findProcessableChildReference();
	return 
		if node.oclIsUndefined() then false else
			node.map structure(node.child).visualID = 0
		endif
}

helper visualIdentity(inout genNode: GMFGEN::GenNodeLabel) {
	if genNode.visualID = 0 then
		genNode.visualID := nodeLabelID()
	endif;
}

helper GMFMAP::LabelMapping::visualIdentity(node: GMFMAP::NodeReference) {
	if self.map createNodeLabel(node).visualID = 0 then
		self.map createNodeLabel(node).visualID := nodeLabelID()
	endif;
}

helper visualIdentity(inout label: GenLinkLabel) {
	if label.visualID = 0 then
		label.visualID := linkLabelID()
	endif;
}

helper GMFMAP::LinkMapping::visualIdentity() {
	if self.map structure().visualID = 0 then {
		self.map structure().visualID := linkNodeID();
		self.map structure().labels->collect(e | visualIdentity(e))
	} endif;
}

helper GMFMAP::CompartmentMapping::visualIdentity(_mapping: NodeMapping, node: NodeReference) {
	if self.map structure(_mapping, node).visualID = 0 then
		self.map structure(_mapping, node).visualID := compartmentID()
	endif 
}
