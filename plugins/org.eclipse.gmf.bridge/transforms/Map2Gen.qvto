/*
 * Copyright (c) 2009 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
modeltype GMFMAP uses mappings('http://www.eclipse.org/gmf/2006/mappings');
modeltype GMFTOOL uses tooldef('http://www.eclipse.org/gmf/2005/ToolDefinition');
modeltype GMFGEN uses gmfgen('http://www.eclipse.org/gmf/2008/GenModel');
modeltype GMFGRAPH uses gmfgraph('http://www.eclipse.org/gmf/2006/GraphicalDefinition');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype GENMODEL uses genmodel('http://www.eclipse.org/emf/2002/GenModel');

--import DiagramRunTimeModel;
import PropertySheet;
import PreferencePages;
import Navigator;
import Actions;
import RichClientPlatformApp;

configuration property rcp : Boolean;
configuration property useMapMode : Boolean;
configuration property useFullRunTime : Boolean;

--
-- Next attempt to author GMFMap-to-GMFGen transformation
--
transformation Map2Gen(in mapModel : GMFMAP, in domainGenModel : GENMODEL, out gmfgenModel : GMFGEN)
--	access transformation Structure(in GMFMAP, inout GMFGEN)
--	access transformation DiagramRunTimeModel(in GMFMAP, inout GMFGEN)
	;

property domainGenModel : GENMODEL::GenModel = null;
	
main() {
	var mapRoot := mapModel.rootObjects()![GMFMAP::Mapping];
	this.domainGenModel := domainGenModel.rootObjects()![GENMODEL::GenModel];
	--
	var genEditor := mapRoot.map structure();
	var gd : GMFGEN::GenDiagram := genEditor.diagram;
	gd.compartments += gd.getAllNodes().compartments; -- DGMT#createGenCompartment
	visualIdentity(mapRoot, gd);
	viewmaps(mapRoot, gd);
	-- ???genEditor.diagram.palette := mapRoot.diagram.map palette();
	gd.palette := mapRoot.diagram.map palette();
	genEditor.domainGenModel := mapRoot.diagram.domainModel.findGenPackage().genModel;
	genEditor.plugin := object GenPlugin {};
	genEditor.editor := object GenEditorView {};
	genEditor.diagramUpdater := object GenDiagramUpdater {};
	-- FIXME allInstances HACK
	if not GMFGEN::GenParserImplementation.allInstances()->isEmpty() then {
		genEditor.labelParsers := object GenParsers {
			implementations += GMFGEN::GenParserImplementation.allInstances();
			if this.designLabelParser <> null then implementations += this.designLabelParser endif;
			if this.auxParser <> null then implementations += this.auxParser endif;
			extensibleViaService := false;
		};
	} endif;
	if not GMFGEN::GenExpressionProviderBase.allInstances()->isEmpty() then {
		genEditor.expressionProviders := object GMFGEN::GenExpressionProviderContainer {
			providers += GMFGEN::GenExpressionProviderBase.allInstances();
		}
	} endif;
	--new DiagramRunTimeModel(domainGenModel XXX need notation.genmodel here instead, gmfgenModel).transform();
	new PropertySheet(mapModel, gmfgenModel).transform();
	new PreferencePages(mapModel, gmfgenModel).transform();
	new Actions(mapModel, gmfgenModel).transform();
	if not rcp then new Navigator(mapModel, gmfgenModel).transform() endif;
	if rcp then new RichClientPlatformApp(mapModel, gmfgenModel).transform() endif;
}

mapping GMFMAP::Mapping::structure() : GMFGEN::GenEditorGenerator@gmfgenModel {
--	new Structure(self, result)->transform();
	diagram := self.diagram.map structure();
	diagram.topLevelNodes += self.nodes.structure();
	-- FIXME allInstances is a HACK
	diagram.childNodes += GMFMAP::ChildReference.allInstances().child.resolve(GMFGEN::GenChildNode);
	diagram.links := self.links->map structure()->asOrderedSet();
	-- model facets
	--
	-- element types
	-- For now, for legacy reasons, setupElementType is invoked at the same places where DGMT used to invoke it
	-- However, for real M2M, I'd prefer to have a single place for all elementTypes setting. FIXME:refactor later
	--diagram.getAllNodes()->forEach(n) { setupElementType(n) };
	--diagram.links->forEach(l) { setupElementType(l) };
	-- <end of element types>
}

-- XXX review - Specialization type is created again and again - why not reuse it?
-- static, for some reasons, helpers couldn't specify 'inout' for context element
-- XXX, actually, don't need GenNode here, GenClass should be sufficient
helper setupElementType(inout genNode : GMFGEN::GenNode) {
	if genNode.modelFacet.oclIsUndefined() then genNode.elementType := object GMFGEN::NotationType {}
	else genNode.elementType := genNode.modelFacet.metaClass.getOrCreateRuntimeMetamodelType() endif;
	return;
}
helper setupElementType(inout genLink : GMFGEN::GenLink) {
	if genLink.modelFacet.oclIsUndefined() then genLink.elementType := object GMFGEN::NotationType {}
	else if genLink.modelFacet.oclIsKindOf(GMFGEN::TypeModelFacet) then
			genLink.elementType := genLink.modelFacet.oclAsType(GMFGEN::TypeModelFacet).metaClass.getOrCreateRuntimeMetamodelType()
		else -- ref-based link; specialize null
			genLink.elementType := object GMFGEN::SpecializationType {} 
		endif
	endif;
	return;
}
query GENMODEL::GenClass::getOrCreateRuntimeMetamodelType() : GMFGEN::ElementType {
	var mmt = self.resolveoneIn(GENMODEL::GenClass::gmfRuntimeMetamodelType, GMFGEN::MetamodelType);
	if mmt.oclIsUndefined() then 
		return self.map gmfRuntimeMetamodelType() 
	endif;
	return object GMFGEN::SpecializationType { metamodelType := mmt }
}
-- XXX ElementType as return value, disjunct?
mapping GENMODEL::GenClass::gmfRuntimeMetamodelType() : GMFGEN::MetamodelType {
}

mapping GMFMAP::CanvasMapping::structure() : GMFGEN::GenDiagram {
	result.domainDiagramElement := self.domainMetaElement.findGenClass();
	if result.domainDiagramElement.oclIsUndefined() then 
		result.elementType := object GMFGEN::NotationType {}
	else
		result.elementType := result.domainDiagramElement.getOrCreateRuntimeMetamodelType()
	endif;
}

helper GMFMAP::TopNodeReference::structure() : GMFGEN::GenTopLevelNode {
	var rv = object GMFGEN::GenTopLevelNode {};
	rv.modelFacet := self.createModelFacet();
	setupElementType(rv);
	var te = self.child.tool.map paletteEntry().oclAsType(ToolEntry); -- FIXME inline nested prop
	te.genNodes += rv;
	self.child.processAbstractNode(rv);
	return rv;
}

helper GMFMAP::NodeReference::createModelFacet() : GMFGEN::TypeModelFacet {
	if self.child.domainMetaElement.oclIsUndefined() then return null endif;
	var mf := object TypeModelFacet {};
	mf.metaClass := self.child.domainMetaElement.findGenClass();
	mf.containmentMetaFeature := self.containmentFeature.findGenFeature();
	if self.childrenFeature.oclIsUndefined() then mf.childMetaFeature := mf.containmentMetaFeature else mf.childMetaFeature := self.childrenFeature.findGenFeature() endif;
	mf.modelElementSelector := self.child.domainSpecialization.map structure(); 
	mf.modelElementInitializer := self.child.domainInitializer.map structure();
	return mf;
}

mapping GMFMAP::LinkMapping::structure() : GMFGEN::GenLink {
	-- model facet
	if self.domainMetaElement.oclIsUndefined() then {
		if self.linkMetaFeature.oclIsUndefined() then result.modelFacet := null else {
			result.modelFacet := object FeatureLinkModelFacet {
				metaFeature := self.linkMetaFeature.findGenFeature();
			};
		} endif 
	} else {
		result.modelFacet := object TypeLinkModelFacet {
			metaClass := self.domainMetaElement.findGenClass();
			containmentMetaFeature := self.containmentFeature.findGenFeature();
			childMetaFeature := containmentMetaFeature;
			sourceMetaFeature := self.sourceMetaFeature.findGenFeature();
			targetMetaFeature := self.linkMetaFeature.findGenFeature();
			modelElementSelector := self.domainSpecialization.map structure(); -- ALTERNATIVE: if not self.domainSpecialization.oclIsUndefined() then modelElementSelector := self.domainSpecialization.map structure() endif; 
			modelElementInitializer := self.domainInitializer.map structure();
		}
	} endif;
	-- labels
	self.labelMappings->forEach(lm) {
		var gl := object GMFGEN::GenLinkLabel {};
		result.labels += gl;
		gl.readOnly := lm.readOnly;
		gl.elementIcon := lm.diagramLabel.elementIcon;
		gl.modelFacet := lm.map createLabelModelFacet();
	};
	var te = self.tool.map paletteEntry().oclAsType(ToolEntry); -- FIXME inline nested prop
	te.genLinks += result;
	setupElementType(result);
	result.creationConstraints := self.creationConstraints.map structure();
}
query EClass::findGenClass() : GENMODEL::GenClass {
	return self.ePackage.findGenPackage().genClassifiers[GenClass]->select(gc | gc.ecoreClass.name = self.name)->first();
}
query EPackage::findGenPackage() : GENMODEL::GenPackage {
	-- XXX GenModel.findGenPackage does more than this (staticGenPackage and nestedGenPackages). FIXME
	-- ->union(genModel.staticGenPackages)
	return this.domainGenModel.genPackages->union(this.domainGenModel.usedGenPackages)->select(gp | gp.ecorePackage.nsURI = self.nsURI)->asSequence()->first();
}
query EStructuralFeature::findGenFeature() : GENMODEL::GenFeature {
	return self.eContainingClass.findGenClass().genFeatures->select(f | f.ecoreFeature = self)->first();
}

helper GMFMAP::NodeMapping::processAbstractNode(inout genNode : GMFGEN::GenNode) {
	genNode.compartments += self.compartments.map structure();
	self.children->forEach(ch) {
		var genChildContainer : GMFGEN::GenChildContainer = genNode;
		if not ch.compartment.oclIsUndefined() then genChildContainer := ch.compartment.resolveone(GMFGEN::GenCompartment) endif;
		var childGenNode : GMFGEN::GenChildNode;
		if ch.child.resolve(GMFGEN::GenChildNode)->isEmpty() then childGenNode := ch.createGenChildNode() else {
			childGenNode := ch.child.resolve(GMFGEN::GenChildNode)->select(gcn | gcn.matchChildReferenceFeatures(ch))->first();
			if childGenNode.oclIsUndefined() then childGenNode := ch.createGenChildNode() endif;
		} endif;
		if (genChildContainer.oclIsKindOf(GMFGEN::GenCompartment) and ch.child.children->size() > 0) then {
			-- FIXME inline, once can modify nested properties
			var genCompartment := genChildContainer.oclAsType(GMFGEN::GenCompartment);
			genCompartment.listLayout := false
		} endif;
		genChildContainer.childNodes += childGenNode;
	};
	genNode.labels += self.labelMappings.map createNodeLabel(genNode);
	genNode.behaviour += self.relatedDiagrams.handleRelatedDiagram(self);
	return null;
}
query GMFGEN::GenChildNode::matchChildReferenceFeatures(childNodeRef : GMFMAP::ChildReference) : Boolean {
	var containmentFeatureMatch : Boolean;
	var childrenFeatureMatch : Boolean;
	-- FIXME modelFacet gets assigned *after* we process structure, hence this logic needs a change
	if self.modelFacet.containmentMetaFeature.oclIsUndefined() then 
		containmentFeatureMatch := childNodeRef.containmentFeature = null 
	else 
		containmentFeatureMatch := childNodeRef.containmentFeature = self.modelFacet.containmentMetaFeature.ecoreFeature
	endif;
	if self.modelFacet.childMetaFeature.oclIsUndefined() then
		childrenFeatureMatch := childNodeRef.childrenFeature = null
	else
		if childNodeRef.childrenFeature = null then 
			childrenFeatureMatch := self.modelFacet.childMetaFeature = self.modelFacet.containmentMetaFeature
		else
			childrenFeatureMatch := self.modelFacet.childMetaFeature.ecoreFeature = childNodeRef.childrenFeature
		endif
	endif;
	return containmentFeatureMatch and childrenFeatureMatch;
} 
mapping GMFMAP::NodeMapping::structure() : GMFGEN::GenChildNode 
	disjuncts GMFMAP::NodeMapping::createGenChildLabelNode, GMFMAP::NodeMapping::createGenChildSideAffixedNode, GMFMAP::NodeMapping::createGenChildNode 
{}

mapping GMFMAP::NodeMapping::createGenChildLabelNode() : GMFGEN::GenChildLabelNode when { self.isPureLabelNode() } {
	var soleLabel := self.labelMappings->first();
	labelModelFacet := soleLabel.map createLabelModelFacet();
	labelReadOnly := soleLabel.readOnly;
	labelElementIcon := soleLabel.diagramLabel.elementIcon;
	-- XXX viewmap :=
	 -- needCompartmentChildrenLabelProcessing = false, no need to processAbstractNode
}
mapping GMFMAP::NodeMapping::createGenChildSideAffixedNode() : GMFGEN::GenChildSideAffixedNode when { self.diagramNode.affixedParentSide <> GMFGRAPH::Direction::NONE} {
	-- XXX viewmap :=
	preferredSideName := self.diagramNode.getAffixedSideAsPositionConstantsName();
	self.processAbstractNode(result);
}
mapping GMFMAP::NodeMapping::createGenChildNode() : GMFGEN::GenChildNode {
	-- XXX viewmap :=
	self.processAbstractNode(result); -- needCompartmentChildrenLabelProcessing = true
}
helper GMFMAP::ChildReference::createGenChildNode() : GMFGEN::GenChildNode {
	-- XXX perhaps, no need to keep this helper, move the code into corresponding mapping operations?
	var rv : GMFGEN::GenChildNode = self.child.map structure();
	var te = self.child.tool.map paletteEntry().oclAsType(ToolEntry); -- FIXME inline nested prop
	te.genNodes += rv;
	rv.modelFacet := self.createModelFacet();
	setupElementType(rv);
	return rv;
}
query GMFMAP::NodeMapping::isPureLabelNode() : Boolean {
	return self.labelMappings->size() = 1 and self.children->isEmpty() and self.labelMappings->first().diagramLabel = self.diagramNode;
}
query GMFGRAPH::Node::getAffixedSideAsPositionConstantsName() : String {
	switch {
		case (self.affixedParentSide = GMFGRAPH::Direction::NONE) assert (false) with log('DiagramNode is not side-affixed', self);
		case (self.affixedParentSide = GMFGRAPH::Direction::EAST) return 'EAST';
		case (self.affixedParentSide = GMFGRAPH::Direction::WEST) return 'WEST';
		case (self.affixedParentSide = GMFGRAPH::Direction::NORTH) return 'NORTH';
		case (self.affixedParentSide = GMFGRAPH::Direction::SOUTH) return 'SOUTH';
		case (self.affixedParentSide = GMFGRAPH::Direction::NSEW) return 'NONE'; -- any side
		--else return 'NONE'; -- any side
	};
	return 'NONE'; -- any side
}
helper GMFMAP::CanvasMapping::handleRelatedDiagram(in mapElement : GMFMAP::MappingEntry) : GMFGEN::OpenDiagramBehaviour {
	var rv = object GMFGEN::OpenDiagramBehaviour {};
	-- XXX alternative approach to tell whether related diagram is the same we are processing now, 
	-- originally self.eResource() != mapElement.eResource()
	if self <> mapElement.container() then {
		rv.diagramKind := 'FIXME put GenEditorGenerator.modelID value here';
		rv.editorID := 'FIXME put GenEditorView.id value here';
	} endif;
	return rv;
}

mapping GMFMAP::CompartmentMapping::structure() : GMFGEN::GenCompartment {
	-- visualID, viewmap and diagramRTclass should get assigned universally
	result.canCollapse := self.compartment.collapsible;
	result.needsTitle := self.compartment.needsTitle;
	result.title := self.compartment.name;
}

mapping GMFMAP::LabelMapping::createNodeLabel(in genNode : GMFGEN::GenNode) : GMFGEN::GenNodeLabel {
	init {
		if self.diagramLabel.external then
			result := object GenExternalNodeLabel {}
		else 
			result := object GenNodeLabel {}
		endif
	}
	-- visualID, diagramRTclass and viewmap should get assigned universally
	result.modelFacet := self.map createLabelModelFacet();
	result.readOnly := self.readOnly;
	result.elementIcon := self.diagramLabel.elementIcon;
}

-- XXX perhaps, can replace with mapping WTF::auxParser() and WTF::externalParser, to use QVTO to create instances when
-- neccessary, the problem is finding a proper WTF (labelMapping knows it's MappingEntry, but latter doesn't keep track of CanvasMapping or similar)
property designLabelParser : GMFGEN::ExternalParser = null;
property auxParser : GMFGEN::ExternalParser = null;
	
-- DGMT#createLabelModelFacet
mapping GMFMAP::LabelMapping::createLabelModelFacet() : GMFGEN::LabelModelFacet {
	if this.auxParser = null then this.auxParser := object GMFGEN::ExternalParser {} endif;
	parser := this.auxParser;
}
-- FIXME use disjuncts instead
mapping GMFMAP::FeatureLabelMapping::createLabelModelFacet() : GMFGEN::LabelModelFacet {
	init {
		var r := object GMFGEN::FeatureLabelModelFacet {};
		r.metaFeatures += self.features.findGenFeature();
		r.editableMetaFeatures += self.editableFeatures.findGenFeature();
		r.viewPattern := self.viewPattern;
		r.editPattern := self.editPattern;
		r.editorPattern := self.editorPattern;
		r.viewMethod := self.viewMethod.convertLabelTextAccessMethod();
		r.editMethod := self.editMethod.convertLabelTextAccessMethod();
		-- if exists then select else 
		-- FIXME allInstances == hack
		var p = GMFGEN::PredefinedParser.allInstances()->any(pp | pp.viewMethod = r.viewMethod and pp.editMethod = r.editMethod);
		if p.oclIsUndefined() then p := object PredefinedParser {viewMethod := r.viewMethod; editMethod := r.editMethod; } endif;
		r.parser := p;
		result := r;
	}
}
query GMFMAP::LabelTextAccessMethod::convertLabelTextAccessMethod() : GMFGEN::LabelTextAccessMethod {
	switch {
		case (self = GMFMAP::LabelTextAccessMethod::NATIVE) return GMFGEN::LabelTextAccessMethod::NATIVE;
		case (self = GMFMAP::LabelTextAccessMethod::REGEXP) return GMFGEN::LabelTextAccessMethod::REGEXP;
		case (self = GMFMAP::LabelTextAccessMethod::PRINTF) return GMFGEN::LabelTextAccessMethod::PRINTF;
		else return GMFGEN::LabelTextAccessMethod::MESSAGE_FORMAT;
	};
	return GMFGEN::LabelTextAccessMethod::MESSAGE_FORMAT;
}
mapping GMFMAP::DesignLabelMapping::createLabelModelFacet() : GMFGEN::LabelModelFacet {
	init {
		result := object GMFGEN::DesignLabelModelFacet {};
	}
	if this.designLabelParser = null then this.designLabelParser := object GMFGEN::ExternalParser {} endif;
	parser := this.designLabelParser;
}

-- *************************************************************************************
-- Visual ID
-- *************************************************************************************

helper visualIdentity(in mapRoot : GMFMAP::Mapping, inout genDiagram : GMFGEN::GenDiagram) {
	genDiagram.visualID := 1000;
	--5.range(1, genDiagram.topLevelNodes->size())->forEach(i) {
	Sequence { 1..genDiagram.topLevelNodes->size() }->forEach(i) {
		var n : GenTopLevelNode := genDiagram.topLevelNodes->at(i);
		n.visualID := 2000 + i;
	};
	Sequence { 1..genDiagram.childNodes->size() }->forEach(i) {
		var n : GenChildNode := genDiagram.childNodes->at(i);
		n.visualID := 3000 + i;
	};
	Sequence { 1..genDiagram.links->size() }->forEach(i) {
		var l : GenLink := genDiagram.links->at(i);
		l.visualID := 4000 + i;
	};
	Sequence { 1..genDiagram.compartments->size() }->forEach(i) {
		var c : GenCompartment := genDiagram.compartments->at(i);
		c.visualID := 7000 + i;
	};
	Sequence { 1..genDiagram.getAllNodes().labels->size() }->forEach(i) {
		var l : GenLabel := genDiagram.getAllNodes().labels->at(i);
		l.visualID := 5000 + i;
	};
	Sequence { 1..genDiagram.links.labels->size() }->forEach(i) {
		var l : GenLabel := genDiagram.links.labels->at(i);
		l.visualID := 6000 + i;
	};
}

-- *************************************************************************************
-- Viewmaps
-- *************************************************************************************

helper viewmaps(in mapRoot : GMFMAP::Mapping, inout genDiagram : GMFGEN::GenDiagram) {
	genDiagram.topLevelNodes->forEach(n) {
		n.viewmap := n.invresolveone(NodeMapping).diagramNode.map viewmap();
	};
	genDiagram.childNodes->forEach(n) {
		n.viewmap := n.invresolveone(NodeMapping).diagramNode.map viewmap();
	};
	genDiagram.links->forEach(l) {
		l.viewmap := l.invresolveone(LinkMapping).diagramLink.map viewmap();
	};
}

mapping GMFGRAPH::Node::viewmap() : GMFGEN::Viewmap {
	init {
		result := object ModeledViewmap { figureModel := self.oclAsType(EObject); };
	}
}

mapping GMFGRAPH::Connection::viewmap() : GMFGEN::Viewmap {
	init {
		result := object ModeledViewmap { figureModel := self.oclAsType(EObject); };
	}
}
mapping GMFGRAPH::DiagramLabel::viewmap() : GMFGEN::Viewmap {
	init {
		result := object ModeledViewmap { figureModel := self.oclAsType(EObject); };
	}
	-- for GenLinkLabel, need to specify alignment based on AlignmentFacet
	-- besides, need to create LabelOffsetAttributes and optionally populate it from LabelOffsetFacet
}

-- *************************************************************************************
-- Constraints and initializers
-- *************************************************************************************

mapping GMFMAP::LinkConstraints::structure() : GMFGEN::GenLinkConstraints {
	sourceEnd := self.sourceEnd.map structure();
	targetEnd := self.targetEnd.map structure();
}

-- note, Constraints may be reused through reuse of NodeMappings, hence need to keep track of the relation
mapping GMFMAP::Constraint::structure() : GMFGEN::GenConstraint {
	result._body := self._body;
	result.bindToProvider(self);
}
mapping GMFMAP::ValueExpression::structure_ve() : GMFGEN::ValueExpression { --XXX think about naming, how to avoid conflict with GenConstraint::structure
	result._body := self._body;
	result.bindToProvider(self);
}
helper GMFGEN::ValueExpression::bindToProvider(in expression : GMFMAP::ValueExpression) {
	if expression.language.detectGenLanguage().oclIsUndefined() then return endif; -- XXX perhaps, don't need this line, if .map would give OclInvalid
	var exprProvider := expression.language.detectGenLanguage().map expressionProvider(); -- FIXME inline, once nested properties are fixed
	exprProvider.expressions += self;
	return;
}
-- XXX actually, looks like I don't need GenLanguage - I can make most decisions based on 
query GMFMAP::Language::detectGenLanguage() : GMFGEN::GenLanguage {
	switch {
		case (self = GMFMAP::Language::ocl) return GMFGEN::GenLanguage::ocl;
		case (self = GMFMAP::Language::java) return GMFGEN::GenLanguage::java;
		case (self = GMFMAP::Language::regexp) return GMFGEN::GenLanguage::regexp;
		case (self = GMFMAP::Language::nregexp) return GMFGEN::GenLanguage::nregexp;
		case (self = GMFMAP::Language::_literal) return GMFGEN::GenLanguage::_literal;
		else { assert (false) with log ('Unknown expression language literal', self); }
	};
	return GMFGEN::GenLanguage::ocl;
}
mapping GMFGEN::GenLanguage::expressionProvider() : GMFGEN::GenExpressionProviderBase {
	init {
		switch {
			case (self = GMFGEN::GenLanguage::ocl) result := object GMFGEN::GenExpressionInterpreter { language := self };
			case (self = GMFGEN::GenLanguage::java) result := object GMFGEN::GenJavaExpressionProvider {};
			case (self = GMFGEN::GenLanguage::regexp) result := object GMFGEN::GenExpressionInterpreter { language := self };
			case (self = GMFGEN::GenLanguage::nregexp) result := object GMFGEN::GenExpressionInterpreter { language := self };
			case (self = GMFGEN::GenLanguage::_literal) result := object GMFGEN::GenLiteralExpressionProvider {};
			else { 
				assert (false) with log ('Unknown expression language literal', self);
				-- fake provider with no language set to fail validation (XXX perhaps, makes sense to add 'unrecognized' language?)
				result := object GMFGEN::GenExpressionInterpreter {};
			}
		}
	}
}

mapping GMFMAP::ElementInitializer::structure() : GMFGEN::GenElementInitializer {
	init {
		assert (false) with log ('No idea how to process ElementInitializer', self);
	}
}

mapping GMFMAP::FeatureSeqInitializer::structure() : GMFGEN::GenElementInitializer {
	init {
		result := object GenFeatureSeqInitializer {
			initializers += self.initializers.map structure();
			elementClass := self.elementClass.findGenClass();
		}
	}
}
mapping GMFMAP::FeatureInitializer::structure() : GMFGEN::GenFeatureInitializer {
	init {
		assert (false) with log ('No idea how to process FeatureInitializer', self);
	}
}

mapping GMFMAP::FeatureValueSpec::structure() : GMFGEN::GenFeatureInitializer {
	init {
		result := object GenFeatureValueSpec {
			feature := self.feature.findGenFeature();
			value := self.value.map structure_ve();
		}
	}
}

mapping GMFMAP::ReferenceNewElementSpec::structure() : GMFGEN::GenFeatureInitializer {
	init {
		result := object GenReferenceNewElementSpec {
			feature := self.feature.findGenFeature();
			-- cast to GenFeatureSeqInitializer was in the original DGMT
			newElementInitializers += self.newElementInitializers.map structure().oclAsType(GMFGEN::GenFeatureSeqInitializer);
		}
	}
}

-- *************************************************************************************
-- Palette
-- *************************************************************************************

mapping GMFMAP::CanvasMapping::palette() : GMFGEN::Palette 
	when { not self.palette.oclIsUndefined(); } {
	--if self.palette.oclIsUndefined() return OclInvalid;
	var paletteItems : Sequence(GMFGEN::ToolGroupItem) := self.palette.tools.map paletteEntry();
	var topLevelTools := paletteItems->asOrderedSet() - paletteItems[GMFGEN::ToolGroup]->asOrderedSet();
	if topLevelTools->notEmpty() then {
		var defaultGroup := object GMFGEN::ToolGroup {
			title := 'Default';
			description := 'Holds top-level non-container tools';
			collapse := false;
			entries += topLevelTools;				
		};
		result.groups := result.groups->prepend(defaultGroup);
	} endif;
	result.groups += paletteItems[GMFGEN::ToolGroup];
	result.flyout := true;
	if (self.palette._default <> null) then {
		var te := self.palette._default.resolveone(GMFGEN::ToolEntry);
		if te <> null then te._default := true else log ('There''s default tool specified for palette, but can''t find gmfgen counterpart') endif;
	} endif;
}

mapping GMFTOOL::AbstractTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		assert (false) with log('Can''t dispatch paletteEntry() for ', self);
	}
}

mapping GMFTOOL::PaletteSeparator::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		result := object GMFGEN::Separator {};
	}
}

mapping GMFTOOL::CreationTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::ToolEntry {};
		setupCommonToolEntry(self, r);
		result := r;
	}
}

mapping GMFTOOL::GenericTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::ToolEntry {};
		r.qualifiedToolName := self.toolClass;
		setupCommonToolEntry(self, r);
		result := r;
	}
}

mapping GMFTOOL::StandardTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::StandardEntry {};
		switch {
			case (self.toolKind = StandardToolKind::SELECT) r.kind := StandardEntryKind::SELECT;  
			case (self.toolKind = StandardToolKind::MARQUEE) r.kind := StandardEntryKind::MARQUEE;			
			case (self.toolKind = StandardToolKind::ZOOM_PAN) r.kind := StandardEntryKind::ZOOM;			
		};
		setupCommonToolEntry(self, r);
		result := r;
	}
}

mapping GMFTOOL::ToolGroup::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::ToolGroup {};
		r.stack := self.stack;
		r.collapse := self.collapsible;
		setupCommonToolEntry(self, r);
		r.entries += self.tools.map paletteEntry();
		result := r;
	}
}

-- XXX or helper GMFGEN::EntryBase::setupCommonToolEntry()?
helper setupCommonToolEntry(in tool : GMFTOOL::AbstractTool, inout genTool : GMFGEN::EntryBase){
	genTool.title := tool.title;
	genTool.description := tool.description;
	if tool.largeIcon.oclIsTypeOf(GMFTOOL::BundleImage) then 
		genTool.largeIconPath := tool.largeIcon.oclAsType(GMFTOOL::BundleImage).constructIconPath() 
	endif;
	if tool.smallIcon.oclIsTypeOf(GMFTOOL::BundleImage) then 
		genTool.smallIconPath := tool.smallIcon.oclAsType(GMFTOOL::BundleImage).constructIconPath()
	endif;
	return null;
}

-- FIXME process path (makeRelative/makeAbsolute) as in original java code
query GMFTOOL::BundleImage::constructIconPath() : String {
	if self.path = null or self.path.size() = 0 then return null endif;
	if self.bundle = null then return self.path endif;
	return self.bundle + '/' + self.path;
}