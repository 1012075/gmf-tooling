
modeltype GMFMAP uses mappings('http://www.eclipse.org/gmf/2006/mappings');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype GENMODEL uses genmodel('http://www.eclipse.org/emf/2002/GenModel');
modeltype GMFGEN uses gmfgen('http://www.eclipse.org/gmf/2009/GenModel');

library Map2GenUtil;

property allChildReferences: Sequence(ChildReference) = Sequence{};
property childReferences: Sequence(ChildReference) = Sequence{};
property equivalentChild: Dict(ChildReference, ChildReference) = Dict{};

property genModel : GENMODEL::GenModel = null;

query GMFMAP::Mapping::getChildReferences(): Sequence(ChildReference) {
	var rs : Sequence(ChildReference) := Sequence{};

	allChildReferences := self.nodes->collect(e | e.child.getChildReferences());
	allChildReferences->forEach(c) {
		var equi: ChildReference = equivalentChild->keys()->selectOne(e | e.matchChildReferenceFeatures(c));
		if equi.oclIsUndefined() then {
			rs += c;
			equivalentChild->put(c, c);
		} else {
			equivalentChild->put(equi, c)
		} endif
	};
	childReferences;
	
	return rs;
-- HACK
--			->reject(e | e.compartment.oclIsUndefined() and 
--				e.containmentFeature = e.childrenFeature and 
--				not e.referencedChild.oclIsUndefined())
}

query NodeMapping::getChildReferences(): Sequence(ChildReference) {
	processedNodeMappings += self;
	return self.children->collect(e |  
			Sequence{e}->union(if processedNodeMappings->includes(e.child) then Sequence {}
			else
				e.child.getChildReferences()
			endif))
}
property processedNodeMappings: Sequence(NodeMapping) = Sequence{};

property compartmentsHistory: Sequence(Tuple(c: CompartmentMapping, n: NodeMapping, r: NodeReference)) = Sequence{};
query GMFMAP::Mapping::getCompartments(): Sequence(Tuple(c: CompartmentMapping, n: NodeMapping, r: NodeReference)) {
	return 
		if compartmentsHistory->notEmpty() then compartmentsHistory else
		self.nodes->collect(e | 
			if not e.child.oclIsUndefined() then 
				e.child.compartments->collect(comp | comp.getSubCompartments(e.child, e)
				)->flatten()
			endif)->flatten()
		endif;
}
query GMFMAP::CompartmentMapping::getSubCompartments(_mapping: NodeMapping, container: NodeReference): 
	Sequence(Tuple(c: CompartmentMapping, n: NodeMapping, r: NodeReference)) {
		
		compartmentsHistory += Tuple{c = self, n = _mapping, r = container};
		
		return Sequence{Tuple{c = self, n = _mapping, r = container}}->union(
			_mapping.children->collect(e | 
				if not e.child.oclIsUndefined() then 
					e.child.compartments->collect(c | 
						if not compartmentsHistory->exists(t | t.c = c and t.n = e.child and t.r = e) then
							c.getSubCompartments(e.child, e) 
						endif)
				endif))->flatten();
	}

helper GMFMAP::ChildReference::matchChildReferenceFeatures(node: GMFMAP::ChildReference) : Boolean {
	var containmentFeatureMatch : Boolean;
	var childrenFeatureMatch : Boolean;
	var childMatch: Boolean;
	
	if node.containmentFeature.oclIsUndefined() then 
		containmentFeatureMatch := self.containmentFeature.oclIsUndefined()
	else {
		containmentFeatureMatch := self.containmentFeature = node.containmentFeature
	} endif;
	
	if node.childrenFeature.oclIsUndefined() then
		childrenFeatureMatch := self.childrenFeature.oclIsUndefined()
	else
		if self.childrenFeature.oclIsUndefined() then 
			childrenFeatureMatch := node.childrenFeature = node.containmentFeature
		else
			childrenFeatureMatch := node.childrenFeature = self.childrenFeature
		endif
	endif;
		
	childMatch := node.referencedChild = self.child or node.child = self.child;
	
	return containmentFeatureMatch and childrenFeatureMatch and childMatch;
}

query ChildReference::findProcessableChildReference(): ChildReference {
	return if childReferences->includes(self) then
		self
	else {
		childReferences->any(e | e.matchChildReferenceFeatures(self))
	} endif
}

-- XXX review - Specialization type is created again and again - why not reuse it?
-- static, for some reasons, helpers couldn't specify 'inout' for context element
-- XXX, actually, don't need GenNode here, GenClass should be sufficient
helper setupElementType(inout genNode : GMFGEN::GenNode) {
	if genNode.modelFacet.oclIsUndefined() then genNode.elementType := object GMFGEN::NotationType {}
	else genNode.elementType := genNode.modelFacet.metaClass.getOrCreateRuntimeMetamodelType() endif;
	return;
}
helper setupElementType(inout genLink : GMFGEN::GenLink) {
	if genLink.modelFacet.oclIsUndefined() then genLink.elementType := object GMFGEN::NotationType {}
	else if genLink.modelFacet.oclIsKindOf(GMFGEN::TypeModelFacet) then
			genLink.elementType := genLink.modelFacet.oclAsType(GMFGEN::TypeModelFacet).metaClass.getOrCreateRuntimeMetamodelType()
		else{ -- ref-based link; specialize null
			genLink.elementType := object GMFGEN::SpecializationType {};
			genLink.elementType.displayName := genLink.modelFacet.oclAsType(FeatureLinkModelFacet).metaFeature.ecoreFeature.name.firstToUpper();}
 		endif
	endif;
	return;
}
query GENMODEL::GenClass::getOrCreateRuntimeMetamodelType() : GMFGEN::ElementType {
	var mmt = self.resolveoneIn(GENMODEL::GenClass::gmfRuntimeMetamodelType, GMFGEN::MetamodelType);
	if mmt.oclIsUndefined() then 
		return self.map gmfRuntimeMetamodelType() 
	endif;
	return object GMFGEN::SpecializationType { metamodelType := mmt }
}
-- XXX ElementType as return value, disjunct?
mapping GENMODEL::GenClass::gmfRuntimeMetamodelType() : GMFGEN::MetamodelType {}

query ECORE::EClass::findGenClass() : GENMODEL::GenClass {
	return self.ePackage.findGenPackage().genClassifiers[GenClass]->select(gc | gc.ecoreClass.name = self.name)->first();
}
query ECORE::EPackage::findGenPackage() : GENMODEL::GenPackage {
	-- XXX GenModel.findGenPackage does more than this (staticGenPackage and nestedGenPackages). FIXME
	-- ->union(genModel.staticGenPackages)
	return this.genModel.genPackages->union(
		this.genModel.usedGenPackages)->select(gp | 
			gp.ecorePackage.nsURI = self.nsURI)->asSequence()->first();
}
query ECORE::EStructuralFeature::findGenFeature() : GENMODEL::GenFeature {
	return self.eContainingClass.findGenClass().genFeatures->select(f | f.ecoreFeature = self)->first();
}

