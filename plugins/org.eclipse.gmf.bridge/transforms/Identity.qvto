/**
 * Copyright (c) 2009 Borland Software Corporation & others
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 *    Guillaume Hillairet (Montages A.G.) 
 */
library Identity;
 
import Mappings; 
import gmf.VisualIdentifierDispenser;

modeltype GMFMAP uses mappings('http://www.eclipse.org/gmf/2006/mappings');
modeltype GMFGEN uses gmfgen('http://www.eclipse.org/gmf/2009/GenModel');
modeltype GMFGRAPH uses gmfgraph('http://www.eclipse.org/gmf/2006/GraphicalDefinition');

-- 
-- Visual Identity
-- 

property labelNodes: Sequence(LabelMapping) = Sequence{};

--
--	Visual IDs are set by traversing the model tree from top to bottom.
--
helper GMFMAP::Mapping::visualIdentity() {
	self.diagram.resolveone(GenDiagram).visualID := 1000;
	
	self.nodes->collect(e |
		if e.resolveone(GenTopLevelNode).visualID <= 0 then {
		 	var genNode := e.resolveone(GenTopLevelNode);
		 	genNode.visualID := genNode.getVisualID();
		 	e.child.compartments->collect(c | c.visualIdentity(e.child, e));
			e.child.children->collect(visualIdentity());
			e.child.labelMappings->collect(visualIdentity(e));
		} endif
	);
	
	self.links->collect(visualIdentity());
		
	return;
}

helper GMFMAP::ChildReference::visualIdentity() {
	var node := self.findProcessableChildReference();
	if not node.oclIsUndefined() then
		if node.map structure(node.child).visualID <= 0 then {
			if not node.referencedChild.oclIsUndefined() then {
				var genNode := node.map structure(node.child);
				genNode.visualID := genNode.getVisualID();
			} else {
				var genNode := node.map structure(node.child);
				genNode.visualID := genNode.getVisualID();
				node.child.children->collect(e |
					if e.needVisualID() then e.visualIdentity() endif
				);
			} endif;
			node.child.compartments->collect(c | c.visualIdentity(node.child, node));
			node.map structure(node.child).labels->collect(e | visualIdentity(e));
		} endif
	endif
}

query ChildReference::needVisualID(): Boolean {
	var node := self.findProcessableChildReference();
	return 
		if node.oclIsUndefined() then false else
			node.map structure(node.child).visualID <= 0
		endif
}

helper visualIdentity(inout genNode: GMFGEN::GenNodeLabel) {
	if genNode.visualID <= 0 then {
		genNode.visualID := genNode.getVisualID();
	} endif;
}

helper GMFMAP::LabelMapping::visualIdentity(node: GMFMAP::NodeReference) {
	if self.map createNodeLabel(node).visualID <= 0 then {
		var genNode := self.map createNodeLabel(node);
		genNode.visualID := genNode.getVisualID();
	} endif;
}

helper visualIdentity(inout label: GenLinkLabel) {
	if label.visualID <= 0 then
		label.visualID := label.getVisualID()
	endif;
}

helper GMFMAP::LinkMapping::visualIdentity() {
	if self.map structure().visualID <= 0 then {
		var genLink := self.map structure();
		genLink.visualID := genLink.getVisualID();
		self.map structure().labels->collect(e | visualIdentity(e))
	} endif;
}

helper GMFMAP::CompartmentMapping::visualIdentity(_mapping: NodeMapping, node: NodeReference) {
	if self.map structure(_mapping, node).visualID <= 0 then {
		var genNode := self.map structure(_mapping, node);
		genNode.visualID := genNode.getVisualID();
	} endif 
}
