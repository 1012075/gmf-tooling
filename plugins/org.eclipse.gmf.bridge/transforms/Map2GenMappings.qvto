/**
 * Copyright (c) 2009 Borland Software Corporation & others
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 *    Guillaume Hillairet (Montages A.G.)
 */
import Map2GenUtil;

library Map2GenMappings;

modeltype GMFMAP uses mappings('http://www.eclipse.org/gmf/2006/mappings');
modeltype GMFTOOL uses tooldef('http://www.eclipse.org/gmf/2005/ToolDefinition');
modeltype GMFGEN uses gmfgen('http://www.eclipse.org/gmf/2009/GenModel');
modeltype GMFGRAPH uses gmfgraph('http://www.eclipse.org/gmf/2006/GraphicalDefinition');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype GENMODEL uses genmodel('http://www.eclipse.org/emf/2002/GenModel');

property mapRoot : GMFMAP::Mapping = null;

mapping GMFMAP::Mapping::structure() : GMFGEN::GenEditorGenerator {
	diagram := self.diagram.map structure();
	
	diagram.topLevelNodes += self.nodes->map structure()->asOrderedSet();
	childReferences->forEach(c) { diagram.childNodes += c.map structure(c.child); };
	
	diagram.links := self.links->map structure()->asOrderedSet();
	self.getCompartments()->forEach(e) { diagram.compartments += e.c.map structure(e.n, e.r); };
	
	diagram.getAllNodes()->forEach(n) { setupElementType(n) };
	diagram.links->forEach(l) { setupElementType(l) };
		 
	if self.expressionsByLanguages()->notEmpty() then 
		expressionProviders := self.map createProviderContainer()
	endif;
}

query GMFMAP::Mapping::expressionsByLanguages(): Sequence(ValueExpression) {
	return GMFMAP::ValueExpression.allInstances()->iterate(it; res: Sequence(ValueExpression) = Sequence{} |
		if res->exists(e | e.language = it.language) then res else res->including(it) endif
	)
} 
mapping GMFMAP::Mapping::createProviderContainer(): GMFGEN::GenExpressionProviderContainer {
	self.expressionsByLanguages()->forEach(e) {
		providers += e.map createExpressionProvider()
	}
}

mapping GMFMAP::CanvasMapping::structure() : GMFGEN::GenDiagram {
	domainDiagramElement := self.domainMetaElement.findGenClass();
	iconProviderPriority := GMFGEN::ProviderPriority::Low;
	validationProviderPriority := GMFGEN::ProviderPriority::Low;
	
	if result.domainDiagramElement.oclIsUndefined() then 
		result.elementType := object GMFGEN::NotationType {}
	else
		result.elementType := result.domainDiagramElement.getOrCreateRuntimeMetamodelType()
	endif;
}

-- *************************************************************************************
-- TopLevelNode
-- *************************************************************************************

mapping GMFMAP::TopNodeReference::structure() : GMFGEN::GenTopLevelNode {
	modelFacet := self.createModelFacet();
	self.child.tool.map paletteEntry().oclAsType(ToolEntry).genNodes += result;
	
	self.child.children->select(e | e.compartment.oclIsUndefined())->forEach(c) {
		var node := c.findProcessableChildReference();
		childNodes += node.map structure(node.child);
	};
	
	labels += self.child.labelMappings->map createNodeLabel(self);
	
--	viewmap := self.child.diagramNode.viewmap();
	behaviour += self.child.relatedDiagrams.handleRelatedDiagram(self.child);
}

-- *************************************************************************************
-- GenChildNode
-- *************************************************************************************

mapping GMFMAP::ChildReference::structure(node: GMFMAP::NodeMapping) : GMFGEN::GenChildNode
	disjuncts 
		GMFMAP::ChildReference::createGenChildLabelNode, 
		GMFMAP::ChildReference::createGenChildSideAffixedNode, 
		GMFMAP::ChildReference::createGenChildNode 
{}

mapping GMFMAP::ChildReference::createGenChildLabelNode(node: GMFMAP::NodeMapping) : GMFGEN::GenChildLabelNode 
	when { node.isPureLabelNode() } {
	
	var soleLabel := node.labelMappings->first();
	labelModelFacet := soleLabel.map createLabelModelFacet(self);
	labelReadOnly := soleLabel.readOnly;
	labelElementIcon := soleLabel.diagramLabel.elementIcon;
--	viewmap := soleLabel.diagramLabel.viewmap();

	self.child.children[ChildReference]->select(e | e.compartment.oclIsUndefined())->forEach(c) {
		var node := c.findProcessableChildReference();
		childNodes += node.map structure(node.child);
	};
	
	modelFacet := self.createModelFacet();
	
	self.child.tool.map paletteEntry().oclAsType(ToolEntry).genNodes += result;
}
mapping GMFMAP::ChildReference::createGenChildSideAffixedNode(node: GMFMAP::NodeMapping) : GMFGEN::GenChildSideAffixedNode 
	when { node.diagramNode.affixedParentSide <> GMFGRAPH::Direction::NONE} {
	
--	viewmap := node.diagramNode.viewmap();
	preferredSideName := node.diagramNode.getAffixedSideAsPositionConstantsName();
	
	labels += node.labelMappings->map createNodeLabel(self);
	
	self.child.children[ChildReference]->select(e | e.compartment.oclIsUndefined())->forEach(c) {
		var node := c.findProcessableChildReference();
		childNodes += node.map structure(node.child);
	};
	
	behaviour += node.relatedDiagrams.handleRelatedDiagram(node);
	modelFacet := self.createModelFacet();
	self.child.tool.map paletteEntry().oclAsType(ToolEntry).genNodes += result;
}
mapping GMFMAP::ChildReference::createGenChildNode(node: GMFMAP::NodeMapping) : GMFGEN::GenChildNode {
--	viewmap := node.diagramNode.viewmap();
	
	labels += node.labelMappings->map createNodeLabel(self); 
	
	self.child.children[ChildReference]->select(e | e.compartment.oclIsUndefined())->forEach(c) {
		var node := c.findProcessableChildReference();
		childNodes += node.map structure(node.child);
	};
	
	behaviour += node.relatedDiagrams.handleRelatedDiagram(node);
	modelFacet := self.createModelFacet();
	
	self.child.tool.map paletteEntry().oclAsType(ToolEntry).genNodes += result;
	
	behaviour += node.visualEffects->map createVisualEffects(result, _node);
}

helper GMFGRAPH::DiagramElement::getOperationName(pin: GMFGRAPH::Pin): String =
	if not self.figure.actualFigure.hasFigurePin(pin) then
		let graphChildAccess = self.figure.accessors->any(_ | _.figure.hasFigurePin(pin)) in
		if graphChildAccess.oclIsUndefined() then
			pin.getOperationName()	
		else
			 graphChildAccess.accessor + "()." + pin.getOperationName()
		endif 
	else pin.getOperationName() endif;

helper GMFGRAPH::Figure::hasFigurePin(pin: GMFGRAPH::Pin): Boolean =
	let realFigure = 
		if self.oclIsTypeOf(FigureRef) then 
			self.oclAsType(FigureRef).figure 
		else self.oclAsType(RealFigure) endif
	in realFigure.pins->includes(pin);
	
mapping GMFMAP::VisualEffectMapping::createVisualEffects(parent: GMFGEN::GenNode, _mapping: GMFMAP::NodeMapping): GMFGEN::GenVisualEffect {
	name := self.diagramPin.name;
	pinKind := self.diagramPin.oclAsType(EObject).eClass().name;
	operationName := self.diagramPin.getOperationName();
	operationType := self.diagramPin.getOperationType();
	oclExpression := self.oclExpression;
	
	-- TODO: need visualID
--	editPolicyQualifiedClassName := parent.getDiagram().editPoliciesPackageName + '.' + 
--		self.diagramPin.name.firstToUpper() +
--	key :=   
}

mapping GMFMAP::LinkMapping::structure() : GMFGEN::GenLink {
	assert(not self.diagramLink.oclIsUndefined()) with log("link diagram link cannot be null");
	if not self.domainMetaElement.oclIsUndefined() then 
		assert(not self.linkMetaFeature.oclIsUndefined()) with log("linkMetaFeature cannot be null")
	endif;
	
	-- model facet
	if not (self.domainMetaElement.oclIsUndefined() and self.linkMetaFeature.oclIsUndefined()) then 
		modelFacet := self.map createModelFacet()
	endif;
	
	-- labels
	labels += self.labelMappings->map structure(self);
	
	self.tool.map paletteEntry().oclAsType(ToolEntry).genLinks += result;
	-- setupElementType(result);
--	result.viewmap := self.diagramLink.viewmap();
	result.creationConstraints := self.creationConstraints.map structure();
}

mapping LabelMapping::structure(link: GMFMAP::LinkMapping): GenLinkLabel {
	readOnly := self.readOnly;
	elementIcon := self.diagramLabel.elementIcon;
	modelFacet := self.map createLabelModelFacet(link);
	var alignmentFacet := self.diagramLabel.findAlignmentFacet();
	if not alignmentFacet.oclIsUndefined() then
		alignment := switch  {
			case (alignmentFacet.alignment = GMFGRAPH::Alignment::BEGINNING) LinkLabelAlignment::SOURCE;
			case (alignmentFacet.alignment = GMFGRAPH::Alignment::CENTER) LinkLabelAlignment::MIDDLE;
			case (alignmentFacet.alignment = GMFGRAPH::Alignment::END) LinkLabelAlignment::TARGET;
			else LinkLabelAlignment::MIDDLE;
		}
	endif;
--	viewmap := self.diagramLabel.viewmap();
--	viewmap.attributes += object LabelOffsetAttributes {
--		var offsetFacet := self.diagramLabel.findOffsetFacet();
--		if not offsetFacet.oclIsUndefined()	then {
--			x := offsetFacet.x;
--			y := offsetFacet.y;
--		} else {
--			y := (link.labelMappings->indexOf(self) + 1) * 20;
--		} endif;
--	}
}

-- *************************************************************************************
-- Compartment
-- *************************************************************************************

mapping GMFMAP::CompartmentMapping::structure(_mapping: GMFMAP::NodeMapping, container: GMFMAP::NodeReference): GMFGEN::GenCompartment {
	init {
		result := object GMFGEN::GenCompartment {
			canCollapse := self.compartment.collapsible;
			needsTitle := self.compartment.needsTitle;
			title := self.compartment.name;
--			viewmap := self.compartment.viewmap();
		};
	}
	
	if container.oclIsKindOf(GMFMAP::TopNodeReference) then
		container.resolveone(GMFGEN::GenNode).compartments += result
	else {
		var node := container.oclAsType(ChildReference).findProcessableChildReference();
		if not node.oclIsUndefined() then
			node.map structure(node.child).compartments += result
		endif
	} endif;
	
	allChildReferences->select(e | e.compartment = self)->forEach(c) {
		if c.child.children->size() > 0 then
			listLayout := false
		endif;
		var node := c.findProcessableChildReference();
			-- if equivalentChild->hasKey(c) then c else 
			-- equivalentChild->keys()->selectOne(e | equivalentChild->get(e)->includes(c)) endif; 
		childNodes += node.map structure(node.child);	
	}
}

helper GMFMAP::NodeReference::createModelFacet() : GMFGEN::TypeModelFacet {
	if self.child.domainMetaElement.oclIsUndefined() then return null endif;
	var mf := object TypeModelFacet {};
	
	mf.metaClass := self.child.domainMetaElement.findGenClass();
	mf.containmentMetaFeature := self.containmentFeature.findGenFeature();
	
	if self.childrenFeature.oclIsUndefined() then 
		mf.childMetaFeature := mf.containmentMetaFeature 
	else 
		mf.childMetaFeature := self.childrenFeature.findGenFeature() 
	endif;
	
	mf.modelElementSelector := self.child.domainSpecialization.map createConstraint(); 
	mf.modelElementInitializer := self.child.domainInitializer.map structure();
	return mf;
}

-- *************************************************************************************
-- Link
-- *************************************************************************************

mapping GMFMAP::LinkMapping::createModelFacet(): GMFGEN::LinkModelFacet 
	disjuncts 
		GMFMAP::LinkMapping::createFeatureLinkModelFacet,
		GMFMAP::LinkMapping::createTypeLinkModelFacet
	{}

mapping GMFMAP::LinkMapping::createFeatureLinkModelFacet() : GMFGEN::FeatureLinkModelFacet when {
	self.domainMetaElement.oclIsUndefined() and not self.linkMetaFeature.oclIsUndefined()} {
	
	metaFeature := self.linkMetaFeature.findGenFeature();
}
mapping GMFMAP::LinkMapping::createTypeLinkModelFacet() : GMFGEN::TypeLinkModelFacet when {
	not self.domainMetaElement.oclIsUndefined()} {
	
	metaClass := self.domainMetaElement.findGenClass();
	containmentMetaFeature := self.containmentFeature.findGenFeature();
	childMetaFeature := containmentMetaFeature;
	sourceMetaFeature := self.sourceMetaFeature.findGenFeature();
	targetMetaFeature := self.linkMetaFeature.findGenFeature();
	modelElementSelector := self.domainSpecialization.map createConstraint(); -- ALTERNATIVE: if not self.domainSpecialization.oclIsUndefined() then modelElementSelector := self.domainSpecialization.map structure() endif; 
	modelElementInitializer := self.domainInitializer.map structure();
}

query DiagramElement::findOffsetFacet(): LabelOffsetFacet {
	return self.facets->selectOne(e | e.oclIsKindOf(LabelOffsetFacet)).oclAsType(LabelOffsetFacet)
}
query DiagramElement::findAlignmentFacet(): AlignmentFacet {
	return self.facets->selectOne(e | e.oclIsKindOf(AlignmentFacet)).oclAsType(AlignmentFacet)
}
query GMFMAP::NodeMapping::isPureLabelNode() : Boolean {
	return self.labelMappings->size() = 1 and self.children->isEmpty() and self.labelMappings->first().diagramLabel = self.diagramNode;
}
query GMFGRAPH::Node::getAffixedSideAsPositionConstantsName() : String {
	switch {
		case (self.affixedParentSide = GMFGRAPH::Direction::NONE) assert (false) with log('DiagramNode is not side-affixed', self);
		case (self.affixedParentSide = GMFGRAPH::Direction::EAST) return 'EAST';
		case (self.affixedParentSide = GMFGRAPH::Direction::WEST) return 'WEST';
		case (self.affixedParentSide = GMFGRAPH::Direction::NORTH) return 'NORTH';
		case (self.affixedParentSide = GMFGRAPH::Direction::SOUTH) return 'SOUTH';
		case (self.affixedParentSide = GMFGRAPH::Direction::NSEW) return 'NONE'; -- any side
		--else return 'NONE'; -- any side
	};
	return 'NONE'; -- any side
}
helper GMFMAP::CanvasMapping::handleRelatedDiagram(in mapElement : GMFMAP::MappingEntry) : GMFGEN::OpenDiagramBehaviour {
	var rv = object GMFGEN::OpenDiagramBehaviour {};
	-- XXX alternative approach to tell whether related diagram is the same we are processing now, 
	-- originally self.eResource() != mapElement.eResource()
	if self <> mapElement.container() then {
		rv.diagramKind := 'FIXME put GenEditorGenerator.modelID value here';
		rv.editorID := 'FIXME put GenEditorView.id value here';
	} endif;
	return rv;
}

-- *************************************************************************************
-- NodeLabel
-- *************************************************************************************

mapping GMFMAP::LabelMapping::createNodeLabel(node: NodeReference) : GMFGEN::GenNodeLabel {
	init {
		if self.diagramLabel.external then
			result := object GenExternalNodeLabel {}
		else 
			result := object GenNodeLabel {}
		endif
	}
	
	result.modelFacet := self.map createLabelModelFacet(node);
	result.readOnly := self.readOnly;
	result.elementIcon := self.diagramLabel.elementIcon;
--	result.viewmap := self.diagramLabel.viewmap();
}

-- XXX perhaps, can replace with mapping WTF::auxParser() and WTF::externalParser, to use QVTO to create instances when
-- neccessary, the problem is finding a proper WTF (labelMapping knows it's MappingEntry, but latter doesn't keep track of CanvasMapping or similar)
property designLabelParser : GMFGEN::ExternalParser = null;
property auxParser : GMFGEN::ExternalParser = null;

-- DGMT#createLabelModelFacet
mapping GMFMAP::LabelMapping::createLabelModelFacet(node: NeedsContainment) : GMFGEN::LabelModelFacet 
	disjuncts 
		GMFMAP::LabelMapping::createDefaultLabelModelFacet,
		GMFMAP::FeatureLabelMapping::createFeatureLabelModelFacet,
		GMFMAP::DesignLabelMapping::createDesignLabelModelFacet,
		GMFMAP::ExpressionLabelMapping::createExpressionLabelModelFacet,
		GMFMAP::OclChoiceLabelMapping::createOclChoiceLabelModelFacet
	{}
mapping GMFMAP::LabelMapping::createDefaultLabelModelFacet(node: NeedsContainment) : GMFGEN::LabelModelFacet 
	when {self.oclIsTypeOf(LabelMapping)} {
	init {
		if this.auxParser = null then 
			this.auxParser := object GMFGEN::ExternalParser {}
		endif;
	}
	parser := this.auxParser;
}
mapping GMFMAP::FeatureLabelMapping::createFeatureLabelModelFacet(node: NeedsContainment) : GMFGEN::FeatureLabelModelFacet {
--	init {
--		result := object FeatureLabelModelFacet {
			metaFeatures += self.features.findGenFeature();
			editableMetaFeatures += self.editableFeatures.findGenFeature();
			viewPattern := self.viewPattern;
			editPattern := self.editPattern;
			editorPattern := self.editorPattern;
			viewMethod := self.viewMethod.convertLabelTextAccessMethod();
			editMethod := self.editMethod.convertLabelTextAccessMethod();
--		}
--	}
--		var r := object GMFGEN::FeatureLabelModelFacet {};
		-- if exists then select else 
		-- FIXME allInstances == hack
		var p = GMFGEN::PredefinedParser.allInstances()->any(pp | 
			pp.viewMethod = result.oclAsType(FeatureLabelModelFacet).viewMethod and 
			pp.editMethod = result.oclAsType(FeatureLabelModelFacet).editMethod);
		
		if p.oclIsUndefined() then p := object PredefinedParser {
			viewMethod := result.oclAsType(FeatureLabelModelFacet).viewMethod; 
			editMethod := result.oclAsType(FeatureLabelModelFacet).editMethod; 
		} endif;
		parser := p;
--	return r;
}
mapping GMFMAP::DesignLabelMapping::createDesignLabelModelFacet(node: NeedsContainment) : GMFGEN::DesignLabelModelFacet {
--	init {
--		result := object DesignLabelModelFacet {}
--	}
	if this.designLabelParser = null then 
		this.designLabelParser := object GMFGEN::ExternalParser {} 
	endif;
	parser := this.designLabelParser;
	
}
mapping GMFMAP::ExpressionLabelMapping::createExpressionLabelModelFacet(node: NeedsContainment): GMFGEN::ExpressionLabelModelFacet {
--	init {
--		result := object ExpressionLabelModelFacet {
			parser := object ExpressionLabelParser {
				expressionContext := GENMODEL::GenClass.allInstances()->any(e | e.ecoreClass = self.mapEntry.getDomainContext());
				viewExpression := if not self.viewExpression.oclIsUndefined() then self.viewExpression.map createValueExpression() endif;
				editExpression := if not self.editExpression.oclIsUndefined() then self.editExpression.map createValueExpression() endif;
				validateExpression := if not self.validateExpression.oclIsUndefined() then self.validateExpression.map createConstraint() endif;
			};
			
--		}
--	}
}
mapping GMFMAP::ValueExpression::createValueExpression(): GMFGEN::ValueExpression 
	disjuncts GMFMAP::ValueExpression::createGenValueExpression, GMFMAP::Constraint::createConstraint
{}
mapping GMFMAP::ValueExpression::createGenValueExpression(): GMFGEN::ValueExpression
	when {self.oclIsTypeOf(ValueExpression)}{
		body := self.body;
}
mapping GMFMAP::Constraint::createConstraint(): GMFGEN::GenConstraint {
	body := self.body;
}
mapping GMFMAP::ValueExpression::createExpressionProvider(): GenExpressionProviderBase {
	init {
		switch {
			case (self.language = Language::java) { result := object GenJavaExpressionProvider {} };
			case (self.language = Language::ocl) { result := object GenExpressionInterpreter { language := self.language() } };
			case (self.language = Language::regexp) { result := object GenExpressionInterpreter { language := self.language() } };
			case (self.language = Language::nregexp) { result := object GenExpressionInterpreter { language := self.language() } };
			case (self.language = GenLanguage::_literal) { result := object GenLiteralExpressionProvider {} };
			else { result := object GenExpressionInterpreter {}; }
		};
	}
	
	expressions += ValueExpression.allInstances()->select(e | e.language = self.language)->map createValueExpression();
}
helper GMFMAP::ValueExpression::language(): GenLanguage {
	return switch {
		case (self.language = Language::java) GenLanguage::java;
		case (self.language = Language::ocl)  GenLanguage::ocl;
		case (self.language = Language::regexp) GenLanguage::regexp;
		case (self.language = Language::nregexp) GenLanguage::nregexp;
		case (self.language = Language::_literal) return GenLanguage::_literal;
		else GenLanguage::ocl;
	}
}
query GMFMAP::ValueExpression::selectProvider(): GenExpressionProviderBase {
	return this.mapRoot->resolveone(GMFGEN::GenExpressionProviderContainer).providers->any(e | e.getLanguage() = self.language)
}
query GMFMAP::LabelTextAccessMethod::convertLabelTextAccessMethod() : GMFGEN::LabelTextAccessMethod {
	switch {
		case (self = GMFMAP::LabelTextAccessMethod::NATIVE) return GMFGEN::LabelTextAccessMethod::NATIVE;
		case (self = GMFMAP::LabelTextAccessMethod::REGEXP) return GMFGEN::LabelTextAccessMethod::REGEXP;
		case (self = GMFMAP::LabelTextAccessMethod::PRINTF) return GMFGEN::LabelTextAccessMethod::PRINTF;
		else return GMFGEN::LabelTextAccessMethod::MESSAGE_FORMAT;
	};
	return GMFGEN::LabelTextAccessMethod::MESSAGE_FORMAT;
}

mapping GMFMAP::OclChoiceLabelMapping::createOclChoiceLabelModelFacet(node: NeedsContainment): GMFGEN::FeatureLabelModelFacet {
	var genFeature = self.feature.findGenFeature();  
	metaFeatures += genFeature;
	editableMetaFeatures += genFeature;
	parser := self.map createOclChoiceParser();
}

mapping GMFMAP::OclChoiceLabelMapping::createOclChoiceParser(): GMFGEN::OclChoiceParser {
	if not self.itemsExpression.oclIsUndefined() then
		result.itemsExpression := self.itemsExpression.map createValueExpression() 
	endif;
	if not self.showExpression.oclIsUndefined() then
		result.showExpression := self.showExpression.map createValueExpression()
	endif;
	
	GenEditorGenerator.allInstances()->asSequence()->first().labelParsers.implementations += result;
}

-- *************************************************************************************
-- Constraints and initializers
-- *************************************************************************************

mapping GMFMAP::LinkConstraints::structure() : GMFGEN::GenLinkConstraints {
	sourceEnd := self.sourceEnd.map createConstraint();
	targetEnd := self.targetEnd.map createConstraint();
}

-- note, Constraints may be reused through reuse of NodeMappings, hence need to keep track of the relation
--mapping GMFMAP::Constraint::structure() : GMFGEN::GenConstraint {
--	result._body := self._body;
--	result.bindToProvider(self);
--}
--mapping GMFMAP::ValueExpression::structure_ve() : GMFGEN::ValueExpression { --XXX think about naming, how to avoid conflict with GenConstraint::structure - disjuncts?
--	result._body := self._body;
--	result.bindToProvider(self);
--}
--helper GMFGEN::ValueExpression::bindToProvider(in expression : GMFMAP::ValueExpression) {
--	if expression.language.detectGenLanguage().oclIsUndefined() then return endif; -- XXX perhaps, don't need this line, if .map would give OclInvalid
--	expression.language.detectGenLanguage().map expressionProvider().expressions += self;
--	return;
--}
-- XXX actually, looks like I don't need GenLanguage - I can make most decisions based on 
--query GMFMAP::Language::detectGenLanguage() : GMFGEN::GenLanguage {
--	switch {
--		case (self = GMFMAP::Language::ocl) return GMFGEN::GenLanguage::ocl;
--		case (self = GMFMAP::Language::java) return GMFGEN::GenLanguage::java;
--		case (self = GMFMAP::Language::regexp) return GMFGEN::GenLanguage::regexp;
--		case (self = GMFMAP::Language::nregexp) return GMFGEN::GenLanguage::nregexp;
--		case (self = GMFMAP::Language::_literal) return GMFGEN::GenLanguage::_literal;
--		else { assert (false) with log ('Unknown expression language literal', self); }
--	};
--	return GMFGEN::GenLanguage::ocl;
--}
--mapping GMFGEN::GenLanguage::expressionProvider() : GMFGEN::GenExpressionProviderBase {
--	init {
--		switch {
--			case (self = GMFGEN::GenLanguage::ocl) result := object GMFGEN::GenExpressionInterpreter { language := self };
--			case (self = GMFGEN::GenLanguage::java) result := object GMFGEN::GenJavaExpressionProvider {};
--			case (self = GMFGEN::GenLanguage::regexp) result := object GMFGEN::GenExpressionInterpreter { language := self };
--			case (self = GMFGEN::GenLanguage::nregexp) result := object GMFGEN::GenExpressionInterpreter { language := self };
--			case (self = GMFGEN::GenLanguage::_literal) result := object GMFGEN::GenLiteralExpressionProvider {};
--			else { 
--				assert (false) with log ('Unknown expression language literal', self);
--				-- fake provider with no language set to fail validation (XXX perhaps, makes sense to add 'unrecognized' language?)
--				result := object GMFGEN::GenExpressionInterpreter {};
--			}
--		}
--	}
--}

-- *************************************************************************************
-- ElementInitializer
-- *************************************************************************************

mapping GMFMAP::ElementInitializer::structure() : GMFGEN::GenElementInitializer {
	init {
		assert (false) with log ('No idea how to process ElementInitializer', self);
	}
}

mapping GMFMAP::FeatureSeqInitializer::structure() : GMFGEN::GenElementInitializer {
	init {
		result := object GenFeatureSeqInitializer {
			initializers += self.initializers.map structure();
			if not self.elementClass.oclIsUndefined() then
				elementClass := self.elementClass.findGenClass()
			endif;
		}
	}
}

-- *************************************************************************************
-- GenFeatureInitializer
-- *************************************************************************************

mapping GMFMAP::FeatureInitializer::structure() : GMFGEN::GenFeatureInitializer {
	init {
		assert (false) with log ('No idea how to process FeatureInitializer', self);
	}
}

mapping GMFMAP::FeatureValueSpec::structure() : GMFGEN::GenFeatureInitializer {
	init {
		result := object GenFeatureValueSpec {
			feature := self.feature.findGenFeature();
			value := self.value.map createValueExpression();
		}
	}
}

mapping GMFMAP::ReferenceNewElementSpec::structure() : GMFGEN::GenFeatureInitializer {
	init {
		result := object GenReferenceNewElementSpec {
			feature := self.feature.findGenFeature();
			-- cast to GenFeatureSeqInitializer was in the original DGMT
			newElementInitializers += self.newElementInitializers.map structure().oclAsType(GMFGEN::GenFeatureSeqInitializer);
		}
	}
}

-- *************************************************************************************
-- Palette
-- *************************************************************************************

mapping GMFMAP::CanvasMapping::palette() : GMFGEN::Palette 
	when { not self.palette.oclIsUndefined(); } {
	--if self.palette.oclIsUndefined() return OclInvalid;
	var paletteItems : Sequence(GMFGEN::ToolGroupItem) := self.palette.tools.map paletteEntry();
	var topLevelTools := paletteItems->reject(e | e.oclIsKindOf(GMFGEN::ToolGroup));
	if topLevelTools->notEmpty() then {
		var defaultGroup := object GMFGEN::ToolGroup {
			title := 'Default';
			description := 'Holds top-level non-container tools';
			collapse := false;
			entries += topLevelTools;
		};
		result.groups := result.groups->prepend(defaultGroup);
	} endif;
	
	result.groups += paletteItems[GMFGEN::ToolGroup];
	result.flyout := true;
	if (self.palette._default <> null) then {
		var te := self.palette._default.resolveone(GMFGEN::ToolEntry);
		if te <> null then te._default := true else log ('There\'s default tool specified for palette, but can\'t find gmfgen counterpart') endif;
	} endif;
}

mapping GMFTOOL::AbstractTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		assert (false) with log('Can\'t dispatch paletteEntry() for ', self);
	}
}

mapping GMFTOOL::PaletteSeparator::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		result := object GMFGEN::Separator {};
	}
}

mapping GMFTOOL::CreationTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::ToolEntry {};
		setupCommonToolEntry(self, r);
		result := r;
	}
}

mapping GMFTOOL::GenericTool::paletteEntry() : GMFGEN::ToolGroupItem 
	when {not self.toolClass.oclIsUndefined() or self.toolClass->notEmpty()} {
	init {
		var r := object GMFGEN::ToolEntry {};
		r.qualifiedToolName := self.toolClass;
		setupCommonToolEntry(self, r);
		result := r;
	}
}

mapping GMFTOOL::StandardTool::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::StandardEntry {};
		switch {
			case (self.toolKind = StandardToolKind::SELECT) r.kind := StandardEntryKind::SELECT;  
			case (self.toolKind = StandardToolKind::MARQUEE) r.kind := StandardEntryKind::MARQUEE;			
			case (self.toolKind = StandardToolKind::ZOOM_PAN) r.kind := StandardEntryKind::ZOOM;			
		};
		setupCommonToolEntry(self, r);
		result := r;
	}
}

mapping GMFTOOL::ToolGroup::paletteEntry() : GMFGEN::ToolGroupItem {
	init {
		var r := object GMFGEN::ToolGroup {};
		r.stack := self.stack;
		r.collapse := self.collapsible;
		setupCommonToolEntry(self, r);
		r.entries += self.tools.map paletteEntry();
		result := r;
	}
}

-- XXX or helper GMFGEN::EntryBase::setupCommonToolEntry()?
helper setupCommonToolEntry(in tool : GMFTOOL::AbstractTool, inout genTool : GMFGEN::EntryBase){
	genTool.title := tool.title;
	genTool.description := tool.description;
	if tool.largeIcon.oclIsTypeOf(GMFTOOL::BundleImage) then 
		genTool.largeIconPath := tool.largeIcon.oclAsType(GMFTOOL::BundleImage).constructIconPath() 
	endif;
	if tool.smallIcon.oclIsTypeOf(GMFTOOL::BundleImage) then 
		genTool.smallIconPath := tool.smallIcon.oclAsType(GMFTOOL::BundleImage).constructIconPath()
	endif;
	return null;
}

-- FIXME process path (makeRelative/makeAbsolute) as in original java code
query GMFTOOL::BundleImage::constructIconPath() : String {
	if self.path.oclIsUndefined() or self.path.trim().size() = 0 then return null endif;
	if self.bundle.oclIsUndefined() or self.bundle.trim().size() = 0 then 
		return self.path.makeRelative() 
	endif;
	return self.bundle.makeAbsolute() + self.path;
}
query String::makeRelative(): String {
	return self;
}
query String::makeAbsolute(): String {
	return if self.startsWith('/') or self->exists(e | e = ':') then self + '/' else '/' + self + '/' endif;
}

-- *************************************************************************************
-- Parsers
-- *************************************************************************************

mapping GMFMAP::Mapping::createGenParsers(): GenParsers {
--	object GenParsers {
	implementations += GMFGEN::GenParserImplementation.allInstances();
	if this.designLabelParser <> null then implementations += this.designLabelParser endif;
	if this.auxParser <> null then implementations += this.auxParser endif;
	extensibleViaService := true;
--		};
}

helper GMFMAP::FeatureLabelMapping::isEnumLabelMapping(): Boolean =
	if self.features->size() <> 1 then false else
		if self.editableFeatures->isEmpty() or self.editableFeatures->size() > self.features->size() then false else
			let firstFeature = self.features->first() in
			let firstEditFeature = self.editableFeatures->first() in
				if firstFeature <> firstEditFeature then false else firstFeature.eType.oclIsKindOf(EEnum) endif
		endif
	endif;
