modeltype DIFF uses diff('http://www.eclipse.org/emf/compare/diff/1.1');
modeltype QVT uses qvtoperational::expressions('http://www.eclipse.org/QVT/1.0.0/Operational');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype OCL uses ocl('http://www.eclipse.org/ocl/1.1.0/OCL');
modeltype IMP uses eimpocl("http://www.eclipse.org/qvt/1.0/ImperativeOCL");
modeltype GMFGEN uses gmfgen('http://www.eclipse.org/gmf/2009/GenModel');

transformation Diff2Qvt(in diffModel: DIFF, in gmfGen: ECORE, in oclStdLib: ECORE, in stdLib: ECORE, out qvtModel: QVT);

property diff: DiffModel = null;
property gmfGenParameter : ModelParameter = null;
property setType: ocl::ecore::SetType = null;
property bagType: ocl::ecore::BagType = null;

main() {
    this.diff := diffModel.rootObjects()![DiffModel];
	this.diff.map toTransformation();
}

--	===========================================================================================================
--	Rules
--	===========================================================================================================

mapping DIFF::DiffModel::toTransformation(): OperationalTransformation {
	name := "GmfGenMigration";
	var genCommonBase = eObject('GenCommonBase');
	var genExternalNodeLabel = eObject('genExternalNodeLabel');
	
	moduleImport := object ModuleImport {
		importedModule := object Library {
			name := 'transforms.util.GmfGenUtil'
		}
	};
	var gmfGen := object ModelType {name := 'GMFGEN'; eSuperTypes := eClass('Model');
		_metamodel := ECORE::EPackage.allInstances()->any(e | e.nsURI = 'http://www.eclipse.org/gmf/2009/GenModel');  
	};
	gmfGenParameter :=  object ModelParameter {
		name := 'gmfGenModel'; eType := gmfGen; kind := DirectionKind::_inout;
	};
	gmfGenParameter.representedParameter := gmfGenParameter.oclAsType(EObject);
	this.bagType := object ocl::ecore::BagType {
		name:='Bag(OclVoid)'; instanceClassName:='org.eclipse.ocl.util.Bag';elementType:= eObject('OclVoid');
	};
	this.setType := object ocl::ecore::SetType {
		name:='Set(GenChildNode)'; instanceClassName:='java.util.Set'; elementType:= genCommonBase;
	};
	modelParameter := gmfGenParameter;
	
	eClassifiers += gmfGen;
	eClassifiers += bagType;
	eClassifiers += setType;
	
	usedModelType += gmfGen;
	eSuperTypes += eClass('Transformation');
	entry := object EntryOperation {
		name := 'main';
		eType := eClass('OclVoid');
		body := object OperationBody {}
	};
	eOperations += entry;
	eOperations += DiffGroup.allInstances()->reject(subDiffElements->forAll(oclIsTypeOf(DiffGroup)))->map toMapping();
}

query DIFF::DiffElement::isCandidate(): Boolean = false;
query DIFF::UpdateAttribute::isCandidate(): Boolean = true;
query DIFF::ModelElementChangeRightTarget::isCandidate(): Boolean = true;
query DIFF::ModelElementChangeLeftTarget::isCandidate(): Boolean = true;

query DIFF::DiffGroup::isCandidate(): Boolean =
	let
		child = self.subDiffElements->reject(oclIsKindOf(DiffGroup))
	in
		child->notEmpty() and
		child->exists(isCandidate()) and	
		(self.rightParent.hasID() or 
			self.rightParent.eContainer().hasID() or 
			self.rightParent.oclIsTypeOf(GenEditorGenerator) or 
			self.rightParent.eContainer().oclIsTypeOf(GenEditorGenerator));
	
query ECORE::EObject::getMappingName(objectID: EObject): String =
	self.eClass().name + objectID.ID().repr();
	
mapping DIFF::DiffGroup::toMapping(): MappingOperation 
	when {
		self.isCandidate()
	}{
	
	eType := eClass('OclVoid');
	context := object VarParameter {
		name := 'self';
		eType := self.rightParent.eClass();
		kind := DirectionKind::_inout;
	};
	
		if (self.rightParent.hasID()) then {
			name := self.rightParent.getMappingName(self.rightParent);
			_when := self.rightParent.createWhenObject(result);
		} else {
			if (self.rightParent.eContainer().hasID()) then {
				name := self.rightParent.getMappingName(self.rightParent.eContainer());
				_when := self.rightParent.eContainer().createWhenObjectContainer(result);
			} else {
				name := self.rightParent.eClass().name
			} endif;	
		} endif;
	
	body := object ConstructorBody {
		content += self.subDiffElements->map toExpression(result)->reject(oclIsUndefined())->reject(oclIsInvalid())
	};
	
	this.diff.map toTransformation().addBodyContent(result, self.rightParent.eClass());
}

mapping DIFF::DiffElement::toExpression(op: MappingOperation): ocl::ecore::OCLExpression
	disjuncts 
		DIFF::UpdateAttribute::toAssignExp,
		DIFF::ModelElementChangeRightTarget::toOperationCallExp,
		DIFF::ModelElementChangeLeftTarget::toOperationCallExp
	{}
	
mapping DIFF::UpdateAttribute::toAssignExp(op: MappingOperation): AssignExp {
	isReset := true;
	
	switch {
		case (self.attribute.eAttributeType.oclIsTypeOf(EEnum)) {
			value := object ocl::ecore::EnumLiteralExp {
				referredEnumLiteral := self.rightElement.eGet(self.attribute).oclAsType(EObject);
			}
		};
		case ('EString' = self.attribute.eAttributeType.name) {
			value := object OCL::ecore::StringLiteralExp {
				stringSymbol := self.rightElement.eGet(self.attribute).repr();
			};
		};
		case (Set{'EInt', 'EInteger'}->includes(self.attribute.eAttributeType.name)) {
			value := object OCL::ecore::IntegerLiteralExp {
				integerSymbol := self.rightElement.eGet(self.attribute).repr().toInteger();
			};
		};
		case ('EDouble' = self.attribute.eAttributeType.name) {
			value := object OCL::ecore::RealLiteralExp {
				realSymbol := self.rightElement.eGet(self.attribute).repr().toReal();
			};
		};
		case ('EBoolean' = self.attribute.eAttributeType.name) {
			var val : Boolean = self.rightElement.eGet(self.attribute).repr() = 'true';
			value := object OCL::ecore::BooleanLiteralExp {
				booleanSymbol := val;
			};
		};
		else 
			value := object OCL::ecore::StringLiteralExp {
				stringSymbol := self.rightElement.eGet(self.attribute).repr();
			};
	};
	
	left := object OCL::ecore::PropertyCallExp {
		eType := eClass('String');
		referredProperty := self.attribute.oclAsType(EObject);
		source := object OCL::ecore::VariableExp {
				name := 'self';
				referredVariable := op.context;
				eType := self.leftElement.eClass();
		}
	};
	eType := eClass('String');
}

mapping DIFF::ModelElementChangeRightTarget::toOperationCallExp(op: MappingOperation): ocl::ecore::OperationCallExp {
	init {
		var feature := self.rightElement.getContainingFeature();
		if not feature.oclIsUndefined() then
			if feature.many then {
				if self.rightElement.hasID() then {
					result := self.rightElement.createRemoveOpeartionCallManyElement(feature, op);
				} else {
					result := null;
				} endif;
			} else {
				result := self.rightElement.createRemoveOpeartionCallOneElement(feature, op);
			} endif
		else 
			result := null
		endif;
	}
}
mapping DIFF::ModelElementChangeLeftTarget::toOperationCallExp(op: MappingOperation): ocl::ecore::OperationCallExp {
	init {
		var feature : EReference := self.leftElement.getContainingFeature();
		if not feature.oclIsUndefined() then
			if feature.many then {
				if self.leftElement.hasID() then {
					result := self.leftElement.createRemoveOpeartionCallManyElement(feature, op);
				} else result := null endif;
			} else {
				result := self.leftElement.createRemoveOpeartionCallOneElement(feature, op);
			} endif
		else result := null endif;
	}
}

helper ECORE::EObject::createRemoveOpeartionCallManyElement(feature: ECORE::EReference, op: MappingOperation): ocl::ecore::OperationCallExp {
	return object ocl::ecore::OperationCallExp {
		referredOperation := eOperation('Model', 'removeElement');
		argument :=  object ocl::ecore::OperationCallExp {
			name := 'node';
			argument := object ocl::ecore::PropertyCallExp {
				referredProperty := feature.oclAsType(EObject);
				upperBound := 1;
				source := object ocl::ecore::VariableExp {name:='self'; referredVariable := op.context}; 
			};
			argument += object ocl::ecore::IntegerLiteralExp {integerSymbol := self.ID().repr().toInteger()}
		};
		source := object ocl::ecore::VariableExp {referredVariable := gmfGenParameter}
	} 
}

helper ECORE::EObject::createRemoveOpeartionCallOneElement(feature: ECORE::EReference, op: MappingOperation): ocl::ecore::OperationCallExp {
	return object ocl::ecore::OperationCallExp {
		referredOperation := eOperation('Model', 'removeElement');
		argument :=  object ocl::ecore::PropertyCallExp {
			referredProperty := feature.oclAsType(EObject);
			upperBound := 1;
			source := object ocl::ecore::VariableExp {name:='self'; referredVariable := op.context}; 
		};
		source := object ocl::ecore::VariableExp {referredVariable := gmfGenParameter}
	}
}

--	===========================================================================================================
--	Helpers
--	===========================================================================================================

helper eClass(type: String): EClass {
	return ECORE::EClass.allInstances()->any(e | e.name = type);
}
helper eObject(name: String): EObject {
	return ECORE::EClass.allInstances()->any(e | e.name = name).oclAsType(EObject);
}
helper eOperation(type: String, name: String): EObject {
	return eClass(type).eAllOperations->any(e | e.name = name).oclAsType(EObject)
}

helper EObject::hasID(): Boolean {
	var id := self.getID();
	return if not self.oclIsUndefined() then self.eIsSet(id) else false endif;
}

helper EObject::getID(): ECORE::EAttribute {
	var id := self.eClass().eIDAttribute;
	if id.oclIsUndefined() then
		id := self.eClass().eAllAttributes->any(_|_.name = 'visualID')
	endif;
	return id;
}
	
helper EObject::ID(): OclAny {
	return self.eGet(self.getID());
}
	
-- self.visualID = 000
helper ECORE::EObject::createWhenObject(op: MappingOperation): OCL::ecore::OperationCallExp =
	object OCL::ecore::OperationCallExp {
			eType := eClass('Boolean');
			referredOperation := eOperation('String_Class', '=');
			upperBound := 1;
			source := 	object OCL::ecore::PropertyCallExp {
				eType := eClass('Integer');
				upperBound := 1;
				name := self.getID().name;
				source := 	object OCL::ecore::VariableExp {
					name := 'self';
					upperBound := 1;
					referredVariable := op.context
				}
			};
			argument += object OCL::ecore::IntegerLiteralExp {
				upperBound := 1;
				integerSymbol:= self.oclAsType(GenCommonBase).visualID;
			}
		};

-- self.container().oclAsType(GenCommonBase).visualID = 000
helper ECORE::EObject::createWhenObjectContainer(op: MappingOperation): OCL::ecore::OperationCallExp =
	object OCL::ecore::OperationCallExp {
			eType := eClass('Boolean');
			name := 'parentID';
			upperBound := 1;
			source := object OCL::ecore::VariableExp {
						name := 'self';
						upperBound := 1; 
						referredVariable := op.context
			};
			argument += object OCL::ecore::IntegerLiteralExp {
				upperBound := 1;
				integerSymbol:= self.ID().repr().toInteger();
			}
		};

helper OperationalTransformation::addBodyContent(op: MappingOperation, eClass: EClass) {
	self.entry.body.content += object ImperativeIterateExp {name := 'xcollect'; eType := bagType;
		source := 
			object ocl::ecore::OperationCallExp {
				eType := setType;
				referredOperation := eOperation('OclType_Class', 'allInstances');
				source := 
					object ocl::ecore::TypeExp {
						eType := eClass;
						referredType:= eClass.oclAsType(EObject)
					};
			};
			var tmp1 := object ocl::ecore::Variable {name:='e'; eType:= eClass};
			body := object MappingCallExp {
				eType := eClass('OclVoid');
				referredOperation := op.oclAsType(EObject);
				source := object ocl::ecore::VariableExp {
							name:= 'e';
							referredVariable:= tmp1;
							eType:= eClass
						}
			};
			iterator := tmp1;
	};
	return null;
}

helper ECORE::EObject::getContainingFeature(): ECORE::EReference = self.eContainingFeature().oclAsType(EReference);
