/*
 * Copyright (c) 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»

«EXTENSION MetaModel»

/*
 * Does instanceof check.
 */
«DEFINE IsInstance(String accessor) FOR GenClass-»
«IF true /*useJavaModelCode*/-»
«accessor» instanceof «getQualifiedInterfaceName()»«ELSE-»
MetaModelFacility.getEClass("«ecoreClass.name»").isSuperTypeOf(«IF true /*isEObjectNotExternalInterface(genClass)*/»«accessor»«ELSE»((org.eclipse.emf.ecore.EObject) «accessor»«ENDIF».eClass())«ENDIF-»
«ENDDEFINE»

«DEFINE NotInstance FOR GenClass-»
// XXX shorthand: !(EXPAND IsInstance)
«ENDDEFINE»

/**
 * Special kind of instanceof check, that compares eContainer() of the object.
 * Since metaClass may be an external interface, eContainer() might need cast to EObject  
 */
«DEFINE IsContainerInstance(String object, GenClass metaClass) FOR GenClass-»
«EXPAND _getEObjectFeature(object, "eContainer()") FOR metaClass» instanceof «getQualifiedInterfaceName()»«ENDDEFINE»

«DEFINE _getEObjectFeature(String object, String feature) FOR GenClass-»
«IF isExternalInterface()»((org.eclipse.emf.ecore.EObject) «object»).«feature»«ELSE»«object».«feature»«ENDIF-»
«ENDDEFINE»

«DEFINE getFeatureValue(String containerVar, genmodel::GenClass containerClass) FOR genmodel::GenFeature-»
«IF isExternalInterface(containerClass)-»
((«getFeatureTargetType()») ((org.eclipse.emf.ecore.EObject) «containerVar»).eGet(«EXPAND MetaFeature»))«-»
«ELSE-»
«containerVar».«getGetAccessor()»()«-»
«ENDIF-»
«ENDDEFINE»

/*
 * FIXME leave only one version of these two getFeatureValue
 *
 * A slightly more sophisticated version of getFeatureValue().
 * @param containerName the name of the container
 * @param feature the feature whose value is in interest
 * @param containerMetaClass the <code>GenClass</code> of the container, or <code>null</code>, if the container is declared as an <code>org.eclipse.emf.ecore.EObject</code>.
 * @param needsCastToResultType whether the cast to the result type is required (this parameter is only used if the <code>org.eclipse.emf.ecore.EClass</code> this feature belongs to is an external interface). 
 */
«DEFINE getFeatureValue(String containerVar, genmodel::GenClass container, boolean needsCastToResultType) FOR genmodel::GenFeature-»
«IF isExternalInterface(genClass)-»
«IF needsCastToResultType»((«getFeatureTargetType()») «ENDIF»«containerVar.parenthesizedCast(container, null)».eGet(«EXPAND MetaFeature»)«IF needsCastToResultType»)«ENDIF-»
«ELSE-»
«containerVar.parenthesizedCast(container, genClass)».«getGetAccessor()»()«-»
«ENDIF-»
«ENDDEFINE»

«DEFINE setFeatureValue(String containerVar, genmodel::GenClass containerGenClass, String valueVar) FOR genmodel::GenFeature-»
	«IF isExternalInterface(containerGenClass)-»
((org.eclipse.emf.ecore.EObject) «containerVar»).eSet(«EXPAND MetaFeature», «valueVar»)«-»
	«ELSE-»
«containerVar».set«getAccessorName(this)»(«valueVar»)«-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE MetaClass FOR genmodel::GenClassifier»«getQualifiedPackageInterfaceName(genPackage)».eINSTANCE.get«getClassifierAccessorName(this)»()«ENDDEFINE»

«DEFINE MetaFeature FOR genmodel::GenFeature»«getQualifiedPackageInterfaceName(genClass.genPackage)».eINSTANCE.get«getFeatureAccessorName(this)»()«ENDDEFINE»

// SomeFactory.eINSTANCE.createBlaBla();
//NB: for map entries, the resulting type is EObject, not the qualified interface name. If cast is needed, use (un)parenthesizedCast() extension.
//see GenClassImpl#hasFactoryInterfaceCreateMethod() for details why map entries should be treated differently
«DEFINE NewInstance FOR genmodel::GenClass-»
«IF isMapEntry()-»
«genPackage.getQualifiedFactoryInterfaceName()».«genPackage.getFactoryInstanceName()».create(«EXPAND MetaClass»)«ELSE-»
«genPackage.getQualifiedFactoryInterfaceName()».«genPackage.getFactoryInstanceName()».create«ecoreClass.name»()«ENDIF-»
«ENDDEFINE»

// XXX Need to take into account possible GenClass from generated and always available code
// e.g. Notation or Ecore 

«DEFINE NewInstance(String varName) FOR genmodel::GenClass-»
«getQualifiedInterfaceName()» «varName» = «IF isMapEntry()»(«getQualifiedInterfaceName()») «ENDIF»«EXPAND NewInstance»;
«ENDDEFINE»

«REM»
XXX looks like we don't use it any longer
«DEFINE NewEObjectInstance(String varName) FOR genmodel::GenClass-»
org.eclipse.emf.ecore.EObject «varName» = «IF !isMapEntry() && isExternalInterface()»(org.eclipse.emf.ecore.EObject) «ENDIF»«EXPAND NewInstance»;
«ENDDEFINE»
«ENDREM»

/*
 * Ensures value is of type EObject, may be no-op if context GenClass is compatible with EObject.
 * Note, injected value is not surrounded with parenthesis, may need to introduce another
 * template to accomplish that if needed.
 */
«DEFINE DowncastToEObject(String value) FOR genmodel::GenClass»«IF isExternalInterface()»(org.eclipse.emf.ecore.EObject) «ENDIF»«value»«ENDDEFINE»

/*
 * Declares new variable of appropriate type and assigns casted value to it.
 */
«DEFINE DeclareAndAssign(String assignee, String value) FOR GenClass-»
«getQualifiedInterfaceName()» «assignee» = («getQualifiedInterfaceName()») «value»;«ENDDEFINE»

// @see IsContainerInstance
«DEFINE DeclareAndAssignContainer(String assignee, String object, GenClass metaClass) FOR GenClass-»
«getQualifiedInterfaceName()» «assignee» = («getQualifiedInterfaceName()») «EXPAND _getEObjectFeature(object, "eContainer()") FOR metaClass»;«ENDDEFINE»

/*
 * Declares new variable of context type and assignes a value obtained from 'src',
 * which is of type 'srcMetaClass', via 'srcFeature'
 *
 * XXX in certain scenarions may need extra cast of the feature value
 */
«DEFINE DeclareAndAssign(String assignee, String src, GenClass srcMetaClass, GenFeature srcFeature) FOR GenClass-»
«getQualifiedInterfaceName()» «assignee» = «EXPAND getFeatureValue(src, srcMetaClass) FOR srcFeature»;«ENDDEFINE»

/*
 * Same as DeclareAndAssign, with extra operation applied to source object
 */
«DEFINE DeclareAndAssign2(String assignee, String src, GenClass srcMetaClass, GenFeature srcFeature, String srcExt, boolean needCast) FOR GenClass-»
«getQualifiedInterfaceName()» «assignee» = «IF needCast»(«getQualifiedInterfaceName()») «ENDIF»«EXPAND getFeatureValue(src, srcMetaClass) FOR srcFeature».«srcExt»;«ENDDEFINE»

/*
 * Cast value of type EObject to specific type. Would be no-op with dynamic model instances,
 * therefore, the fact eObjectValue is actually EObject is essential
 */
«DEFINE CastEObject(String eObjectValue) FOR GenClass»(«getQualifiedInterfaceName()») «eObjectValue»«ENDDEFINE»

/**
 * Qualified interface name of the generated EClass, or EObject for dynamic models.
 * Use whenever class name is inevitable (e.g. method arguments)
 * SHOULD NEVER APPEAR in instanceof or any other similar comparison operation
 */
«DEFINE QualifiedClassName FOR GenClass»«getQualifiedInterfaceName()»«ENDDEFINE»

«DEFINE PopulateItemProviderFactories(String factoryListVar) FOR GenEditorGenerator-»
«FOREACH getAllDomainGenPackages(true) AS genPackage-»
		«factoryListVar».add(new «genPackage.getQualifiedItemProviderAdapterFactoryClassName()»());
«ENDFOREACH-»
«ENDDEFINE»

«DEFINE Facility FOR GenEditorGenerator»
public class MetaModelFacility {

	private static MetaModelFacility instance;

	private MetaModelFacility(EPackage ePackage) {
	}

	private void doInit() {
	«FOREACH getAllDomainGenPackages(true) AS genPackage-»
	«ENDFOREACH»
	}

	public static MetaModelFacility get«"NameBasedOnMetaModelPackageName"»() {
		if (instance«"XX"» == null) {
			instance«"XX"» = new MetaModelFacility(«"load EPackage"»);
			instance«"XX"».doInit();
		}
		return instance«"XX"»;
	}

	public static isInstance(EObject obj, String metaClassName) {
		EClass eMetaClass = getInstance(metaModelName).findMetaClass(metaClassName);
		return obj != null && eMetaClass.isSuperTypeOf(obj.eClass());
	}

	public static EObject newInstance(String metaClassName) {
	}

	public static EClass getEClass(String metaClassName) {
		return instance.findMetaClass(metaClassName);
	}
}
«ENDDEFINE»