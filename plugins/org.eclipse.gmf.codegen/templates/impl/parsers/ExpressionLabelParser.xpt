/*
 * Copyright (c) 2010 Artem Tikhomirov and others
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (independent) - Initial API and implementation
 */

«IMPORT 'http://www.eclipse.org/gmf/2009/GenModel'»

«DEFINE fields(gmfgen::ExpressionLabelParser parser) FOR gmfgen::LabelModelFacet»«ERROR 'ExpressionLabelParser can be used with ExpressionLabelModelFacet only, not with ' + self.repr()»«ENDDEFINE»

«DEFINE fields(gmfgen::ExpressionLabelParser parser) FOR gmfgen::ExpressionLabelModelFacet-»
«IF not viewExpression.oclIsUndefined() and viewExpression.provider.oclIsKindOf(gmfgen::GenExpressionInterpreter)-»

	«EXPAND xpt::Common::generatedMemberComment»
	private final «parser.holder.editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» printExpression;
«ENDIF-»

«IF not editExpression.oclIsUndefined() and editExpression.provider.oclIsKindOf(gmfgen::GenExpressionInterpreter)-»

	«EXPAND xpt::Common::generatedMemberComment»
	private final «parser.holder.editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» editExpression;
«ENDIF-»

«IF not validateExpression.oclIsUndefined() and validateExpression.provider.oclIsKindOf(gmfgen::GenExpressionInterpreter)-»

	«EXPAND xpt::Common::generatedMemberComment»
	private final «parser.holder.editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» validateExpression;
«ENDIF-»
«ENDDEFINE»

«DEFINE consInit(gmfgen::ExpressionLabelParser parser) FOR gmfgen::LabelModelFacet»«ERROR 'ExpressionLabelParser can be used with ExpressionLabelModelFacet only, not with ' + self.repr()»«ENDDEFINE»

«DEFINE consInit(gmfgen::ExpressionLabelParser parser) FOR gmfgen::ExpressionLabelModelFacet-»
«IF not viewExpression.oclIsUndefined()-»
«EXPAND _initField('this.printExpression', viewExpression, self.eContainer().oclAsType(gmfgen::GenCommonBase) /*this cast is not really good, but can not find better alternative*/) FOR viewExpression.provider-»
«ENDIF-»
«IF not editExpression.oclIsUndefined()-»
«EXPAND _initField('this.editExpression', editExpression, self.eContainer().oclAsType(gmfgen::GenCommonBase)) FOR editExpression.provider-»
«ENDIF-»
«IF not validateExpression.oclIsUndefined()-»
«EXPAND _initField('this.validateExpression', validateExpression, self.eContainer().oclAsType(gmfgen::GenCommonBase)) FOR validateExpression.provider-»
«ENDIF-»
«ENDDEFINE»

«DEFINE _initField(String fieldName, gmfgen::ValueExpression expression, gmfgen::GenCommonBase labelOwner) FOR gmfgen::GenExpressionProviderBase-»
«REM»
NO-OP, do not need fields for anything but interpreted expressions (nor java, nor literal at the moment)
«ENDREM-»
«ENDDEFINE»

«DEFINE _initField(String fieldName, gmfgen::ValueExpression expression, gmfgen::GenCommonBase labelOwner) FOR gmfgen::GenExpressionInterpreter-»
«fieldName» = «EXPAND xpt::expressions::getExpression::getExpression(expression, labelOwner.oclAsType(GenNode).modelFacet.metaClass)»;
«ENDDEFINE»

«DEFINE accessEditExpression FOR gmfgen::LabelModelFacet»«ERROR 'ExpressionLabelParser can be used with ExpressionLabelModelFacet only, not with ' + self.repr()»«ENDDEFINE»
«DEFINE accessViewExpression FOR gmfgen::LabelModelFacet»«ERROR 'ExpressionLabelParser can be used with ExpressionLabelModelFacet only, not with ' + self.repr()»«ENDDEFINE»
«DEFINE accessValidateExpression FOR gmfgen::LabelModelFacet»«ERROR 'ExpressionLabelParser can be used with ExpressionLabelModelFacet only, not with ' + self.repr()»«ENDDEFINE»

«DEFINE accessEditExpression FOR gmfgen::ExpressionLabelModelFacet-»
«IF editExpression.oclIsUndefined()-»
	return getPrintString(element, flags);
«ELSE-»
«EXPAND _evaluateAndReturnExpressionResult('this.editExpression', 'evaluateEditExpression', editExpression) FOR editExpression.provider-»
«ENDIF-»
«ENDDEFINE»

«DEFINE accessViewExpression FOR gmfgen::ExpressionLabelModelFacet-»
«IF viewExpression.oclIsUndefined()-»
	// TODO
	throw new UnsupportedOperationException();
«ELSE-»
«EXPAND _evaluateAndReturnExpressionResult('this.printExpression', 'evaluatePrintExpression', viewExpression) FOR viewExpression.provider-»
«ENDIF-»
«ENDDEFINE»

«DEFINE _evaluateAndReturnExpressionResult(String expressionFieldName, String javaMethodName, ValueExpression expression) FOR gmfgen::GenExpressionProviderBase»«ERROR 'Abstract template call: _evaluateAndReturnExpressionResult'»«ENDDEFINE»
«DEFINE _evaluateAndReturnExpressionResult(String expressionFieldName, String javaMethodName, ValueExpression expression) FOR gmfgen::GenExpressionInterpreter-»
org.eclipse.emf.ecore.EObject target = (org.eclipse.emf.ecore.EObject) element.getAdapter(org.eclipse.emf.ecore.EObject.class);
Object result = «expressionFieldName».evaluate(target);
return String.valueOf(result);
«ENDDEFINE»
«DEFINE _evaluateAndReturnExpressionResult(String expressionFieldName, String javaMethodName, ValueExpression expression) FOR gmfgen::GenJavaExpressionProvider-»
return «javaMethodName»((org.eclipse.emf.ecore.EObject) element.getAdapter(org.eclipse.emf.ecore.EObject.class));
«ENDDEFINE»
«DEFINE _evaluateAndReturnExpressionResult(String expressionFieldName, String javaMethodName, ValueExpression expression) FOR gmfgen::GenLiteralExpressionProvider-»
return «expression.body»;
«ENDDEFINE»


«DEFINE accessValidateExpression FOR gmfgen::ExpressionLabelModelFacet-»
«IF not validateExpression.oclIsUndefined() -»
	if («IF validateExpression.provider.getLanguage() = gmfgen::GenLanguage::_literal»!«validateExpression.body»«ELSE»Boolean.FALSE.equals(«IF validateExpression.provider.oclIsKindOf(gmfgen::GenExpressionInterpreter)»this.validateExpression.evaluate(editString)«ELSEIF validateExpression.provider.oclIsKindOf(gmfgen::GenJavaExpressionProvider)»evaluateValidateExpression(editString)«ENDIF»)«ENDIF») {
		return org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus.UNEDITABLE_STATUS;
	} // else fall-through
«ENDIF-»
	return org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus.EDITABLE_STATUS;
«ENDDEFINE»

«DEFINE extraMethods FOR gmfgen::LabelModelFacet»«ERROR 'ExpressionLabelParser can be used with ExpressionLabelModelFacet only, not with ' + self.repr()»«ENDDEFINE»

«DEFINE extraMethods FOR gmfgen::ExpressionLabelModelFacet-»
«IF not viewExpression.oclIsUndefined() and viewExpression.provider.oclIsKindOf(gmfgen::GenJavaExpressionProvider)»
	«EXPAND _javaMethod('evaluatePrintExpression', 'String', 'org.eclipse.emf.ecore.EObject', viewExpression) FOR viewExpression.provider.oclAsType(gmfgen::GenJavaExpressionProvider)-»
«ENDIF-»
«IF not editExpression.oclIsUndefined() and editExpression.provider.oclIsKindOf(gmfgen::GenJavaExpressionProvider)»
	«EXPAND _javaMethod('evaluateEditExpression', 'String', 'org.eclipse.emf.ecore.EObject', editExpression) FOR editExpression.provider.oclAsType(gmfgen::GenJavaExpressionProvider)-»
«ENDIF-»
«IF not validateExpression.oclIsUndefined() and validateExpression.provider.oclIsKindOf(gmfgen::GenJavaExpressionProvider)»
	«EXPAND _javaMethod('evaluateValidateExpression', 'Boolean', 'String', validateExpression) FOR validateExpression.provider.oclAsType(gmfgen::GenJavaExpressionProvider)-»
«ENDIF-»
«ENDDEFINE»

«DEFINE _javaMethod(String methodName, String returnType, String paramType, ValueExpression expression) FOR gmfgen::GenJavaExpressionProvider-»
	«EXPAND xpt::Common::generatedMemberComment»
	private «returnType» «methodName»(«paramType» self) {
«IF injectExpressionBody and (expression.body <> null and expression.body.size() > 0)-»
		«expression.body»
«ELSEIF throwException or (injectExpressionBody and (expression.body = null or expression.body.size() = 0))-»
		// TODO: implement this method to return «returnType» value  
		// Ensure that you remove @generated or mark it @generated NOT
		throw new java.lang.UnsupportedOperationException("No user java implementation provided in '«methodName»' operation");«EXPAND xpt::Common::nonNLS»
«ELSE-»
		return null;
«ENDIF-»	
	}
«ENDDEFINE»