import xpt.StringOperations;

modeltype genModel uses "http://www.eclipse.org/gmf/2008/GenModel";

library Utils;

helper genModel::Palette::activatorFQN() : String {
	return self.diagram.editorGen.plugin.getActivatorQualifiedClassName()
}

helper genModel::AbstractToolEntry::activatorFQN() : String {
	return self.group.palette.activatorFQN()
}

helper genModel::ToolGroup::activatorFQN() : String {
	return self.palette.activatorFQN()
}

helper i18nKey(group : genModel::EntryBase) : String {
	return let rv = group.createMethodName in (if rv.xpandStartsWith('get') then rv.xpandSubstring(3) else (if rv.xpandStartsWith('create') then rv.xpandSubstring(6) else rv endif) endif)
}

helper i18nTitleKey(group : genModel::EntryBase) : String {
	return i18nKey(group) + '_title'
}

helper i18nDescKey(group : genModel::EntryBase) : String {
	return i18nKey(group) + '_desc'
}

helper collectGroups(palette : genModel::Palette) : Sequence(genModel::ToolGroup) {
	return palette.groups->asSequence()->union(palette.groups->collect(it | collectSubGroups(it)))->asOrderedSet()->asSequence()
}

helper collectSubGroups(group : genModel::ToolGroup) : Sequence(genModel::ToolGroup) {
	return let rv = (group.entries)[genModel::ToolGroup] in rv->union(rv->collect(g | collectSubGroups(g))->flatten()->asSet())->asSequence()
}

helper collectTools(palette : genModel::Palette) : Sequence(genModel::AbstractToolEntry) {
	return collectGroups(palette)->collect(g | (g.entries)[genModel::AbstractToolEntry])->flatten()
}

helper needsNodeToolEntryClass(palette : genModel::Palette) : Boolean {
	return (collectTools(palette))[genModel::ToolEntry]->exists(e | not e.genNodes->isEmpty())
}

helper needsLinkToolEntryClass(palette : genModel::Palette) : Boolean {
	return (collectTools(palette))[genModel::ToolEntry]->exists(e | not e.genLinks->isEmpty())
}
