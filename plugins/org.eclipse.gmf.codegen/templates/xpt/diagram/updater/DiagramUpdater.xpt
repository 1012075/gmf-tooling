/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»

«EXTENSION xpt::diagram::updater::Utils»
«EXTENSION xpt::diagram::editpolicies::LinkUtils»
«EXTENSION xpt::GenModelUtils»

«DEFINE DiagramUpdater FOR gmfgen::GenDiagramUpdater-»
	«EXPAND xpt::Common::copyright FOR editorGen-»
package «editorGen.editor.packageName»;

	«EXPAND xpt::Common::generatedClassComment»
public class «diagramUpdaterClassName» {
	«EXPAND isShortcutOrphaned-»
«LET editorGen.diagram.getAllContainers().select(container | hasSemanticChildren(container)) AS semanticContainers-»

	«EXPAND getGenericSemanticChildrenOfView(semanticContainers)-»
	«EXPAND getSemanticChildrenOfView FOREACH semanticContainers-»
	«EXPAND getSemanticChildrenOfModelElement FOREACH semanticContainers-»
	«EXPAND getPhantomNodesIterator-»
	
	«EXPAND isDomainMetaChild FOREACH semanticContainers-»
«ENDLET-»
«LET getAllSemanticElements(editorGen.diagram) AS semanticElements-»

	«EXPAND getGenericConnectedLinks(semanticElements, getContainedLinksMethodNameSuffix())-»
	
	«EXPAND getGenericConnectedLinks(semanticElements, getIncomingLinksMethodNameSuffix())-»
	
	«EXPAND getGenericConnectedLinks(semanticElements, getOutgoingLinksMethodNameSuffix())-»
	«EXPAND getContainedLinks FOREACH semanticElements-»
	«EXPAND getIncomingLinks FOREACH semanticElements-»
	«EXPAND getOutgoingLinks FOREACH semanticElements-»
	«EXPAND getContainedLinksByTypeMethod FOREACH getAllContainedLinks(editorGen.diagram)-»
	«EXPAND getIncomingLinksByTypeMethod FOREACH getAllIncomingLinks(editorGen.diagram)-»
	«EXPAND getOutgoingLinksByTypeMethod FOREACH getAllOutgoingLinks(editorGen.diagram).select(link | null == getTypeModelFacet(link) || null != getTypeModelFacet(link).sourceMetaFeature)-»
«ENDLET-»

	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE isShortcutOrphaned FOR gmfgen::GenDiagramUpdater-»
	«IF !editorGen.diagram.containsShortcutsTo.isEmpty()-»

	«EXPAND xpt::Common::generatedMemberComment»
public static boolean isShortcutOrphaned(org.eclipse.gmf.runtime.notation.View view) {
	return view.getEAnnotation("Shortcut") != null && view.isSetElement() && (view.getElement() == null || view.getElement().eIsProxy()); «EXPAND xpt::Common::nonNLS»
}
	«ENDIF-»
«ENDDEFINE»

«DEFINE getGenericSemanticChildrenOfView(List[gmfgen::GenContainerBase] semanticContainers) FOR gmfgen::GenDiagramUpdater-»
	«EXPAND xpt::Common::generatedMemberComment»
public static java.util.List getSemanticChildren(org.eclipse.gmf.runtime.notation.View view) {
	«IF !semanticContainers.isEmpty()-»
	switch («EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR editorGen.diagram»(view)) {
		«EXPAND getSemanticChildrenCase FOREACH semanticContainers-»
	}
	«ENDIF-»
	return java.util.Collections.EMPTY_LIST;
}
«ENDDEFINE»

«DEFINE getSemanticChildrenCase FOR gmfgen::GenContainerBase-»
«EXPAND xpt::Common::caseVisualID»
	return «EXPAND getSemanticChildrenMethodName»(view);
«ENDDEFINE»

«DEFINE getSemanticChildrenOfView FOR gmfgen::GenContainerBase-»

	«EXPAND xpt::Common::generatedMemberComment»
public static java.util.List «EXPAND getSemanticChildrenMethodName»(org.eclipse.gmf.runtime.notation.View view) {
	«IF getSemanticChildren(this).size() > 0-»
	«EXPAND getModelelementType» modelElement = («EXPAND getModelelementType») view.getElement();
	java.util.List result = new java.util.LinkedList();
	for (java.util.Iterator semanticIterator = «EXPAND getSemanticChildrenMethodName»(modelElement).iterator(); semanticIterator.hasNext();) {
		org.eclipse.emf.ecore.EObject nextElement = (org.eclipse.emf.ecore.EObject) semanticIterator.next();
		int visualID = «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall FOR getDiagram()»(view, nextElement);
		if («EXPAND isDomainMetaChildMethodName»(visualID)) {
			result.add(new «getDiagram().editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»(nextElement, visualID));
		}
	}
	return result;
	«ELSE-»
	return java.util.Collections.EMPTY_LIST;
	«ENDIF-»
}
«ENDDEFINE»

«DEFINE getSemanticChildrenOfModelElement FOR gmfgen::GenContainerBase-»
	«IF getSemanticChildren(this).size() > 0-»
	
	«EXPAND xpt::Common::generatedMemberComment»
private static java.util.List «EXPAND getSemanticChildrenMethodName»(«EXPAND getModelelementType» modelElement) {
	java.util.List allValues = new java.util.LinkedList();
	«EXPAND collectAllFeatureFalues(getModelElementType()) FOR getSemanticChildrenChildFeatures(this)-»
	«EXPAND collectPotentialPhantomNodes-»
	return allValues;
}
	«ENDIF-»
«ENDDEFINE»

«DEFINE getSemanticChildrenMethodName FOR gmfgen::GenContainerBase»get«getUniqueIdentifier()»SemanticChildren«ENDDEFINE»

«DEFINE getSemanticChildrenMethodCall FOR gmfgen::GenContainerBase»«getDiagram().editorGen.diagramUpdater.getDiagramUpdaterQualifiedClassName()».«EXPAND getSemanticChildrenMethodName»«ENDDEFINE»

«DEFINE getModelelementType FOR gmfgen::GenContainerBase»«getQualifiedInterfaceName(getModelElementType())»«ENDDEFINE»

«DEFINE collectAllFeatureFalues(genmodel::GenClass containerGenClass) FOR Set[genmodel::GenFeature]-»
	«FOREACH this AS childFeature-»
		«IF null == childFeature-»
allValues.add(/*FIXME no containment/child feature found in the genmodel, toolsmith need to specify correct one here manually*/);
		«ELSEIF isListType(childFeature)-»
allValues.addAll(«EXPAND xpt::Common::getFeatureValue("modelElement", containerGenClass) FOR childFeature»);
		«ELSE-»
allValues.add(«EXPAND xpt::Common::getFeatureValue("modelElement", containerGenClass) FOR childFeature»);
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE collectPotentialPhantomNodes FOR gmfgen::GenContainerBase»«ENDDEFINE»

«DEFINE collectPotentialPhantomNodes FOR gmfgen::GenDiagramUpdater-»
	«IF !getPhantomNodes(editorGen.diagram).isEmpty()-»
org.eclipse.emf.ecore.resource.Resource resource = modelElement.eResource();
for (java.util.Iterator semanticIterator = getPhantomNodesIterator(resource); semanticIterator.hasNext();) {
	org.eclipse.emf.ecore.EObject nextElement = (org.eclipse.emf.ecore.EObject) semanticIterator.next();
	if (nextElement == modelElement) {
		continue;
	}
	«EXPAND addNextIfPhantom FOREACH getPhantomNodes(editorGen.diagram)-»
}
	«ENDIF-»
«ENDDEFINE»

«DEFINE addNextIfPhantom FOR gmfgen::GenNode-»
if («EXPAND xpt::Common::metaClassAccessor FOR modelFacet.metaClass».isSuperTypeOf(nextElement.eClass())) {
	allValues.add(nextElement);
	continue;
}
«ENDDEFINE»

«DEFINE getPhantomNodesIterator FOR gmfgen::GenDiagramUpdater-»
	«IF !getPhantomNodes(editorGen.diagram).isEmpty()-»
	
	«EXPAND xpt::Common::generatedMemberComment»
private static java.util.Iterator getPhantomNodesIterator(org.eclipse.emf.ecore.resource.Resource resource) {
	return resource.getAllContents();
}
	«ENDIF-»
«ENDDEFINE»

«DEFINE isDomainMetaChild FOR gmfgen::GenContainerBase-»
	«EXPAND xpt::Common::generatedMemberComment»
public static boolean «EXPAND isDomainMetaChildMethodName»(int visualID) {
	«IF !getSemanticChildren(this).isEmpty()-»
	switch (visualID) {
	«EXPAND xpt::Common::caseVisualID FOREACH getSemanticChildren(this)»
		return true;
	}
	«ENDIF-»
	return false;
}
«ENDDEFINE»

«DEFINE isDomainMetaChildMethodName FOR gmfgen::GenContainerBase»is«getUniqueIdentifier()»DomainMetaChild«ENDDEFINE»

«DEFINE isDomainMetaChildMethodCall FOR gmfgen::GenContainerBase»«getDiagram().editorGen.diagramUpdater.getDiagramUpdaterQualifiedClassName()».«EXPAND isDomainMetaChildMethodName»«ENDDEFINE»

«DEFINE getGenericConnectedLinks(List[gmfgen::GenCommonBase] linkContainers, String methodNameSuffix) FOR gmfgen::GenDiagramUpdater-»
	«EXPAND xpt::Common::generatedMemberComment»
public static java.util.List get«methodNameSuffix»Links(org.eclipse.gmf.runtime.notation.View view) {
	«IF !linkContainers.isEmpty()-»
	switch («EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR editorGen.diagram»(view)) {
		«EXPAND getContainedLinksCase(methodNameSuffix) FOREACH linkContainers-»
	}
	«ENDIF-»
	return java.util.Collections.EMPTY_LIST;
}
«ENDDEFINE»

«DEFINE getContainedLinksCase(String methodNameSuffix) FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::caseVisualID»
	return «EXPAND linkGetterName(methodNameSuffix)»(view);
«ENDDEFINE»

«REM»This DEFING can be used from other templates to inject call to the corresponding method«ENDREM»
«DEFINE getContainedLinksMethodCall FOR gmfgen::GenCommonBase»«getDiagram().editorGen.diagramUpdater.getDiagramUpdaterQualifiedClassName()».«EXPAND linkGetterName(getContainedLinksMethodNameSuffix())»«ENDDEFINE»

«REM»This DEFING can be used from other templates to inject call to the corresponding method«ENDREM»
«DEFINE getIncomingLinksMethodCall FOR gmfgen::GenCommonBase»«getDiagram().editorGen.diagramUpdater.getDiagramUpdaterQualifiedClassName()».«EXPAND linkGetterName(getIncomingLinksMethodNameSuffix())»«ENDDEFINE»

«REM»This DEFING can be used from other templates to inject call to the corresponding method«ENDREM»
«DEFINE getOutgoingLinksMethodCall FOR gmfgen::GenCommonBase»«getDiagram().editorGen.diagramUpdater.getDiagramUpdaterQualifiedClassName()».«EXPAND linkGetterName(getOutgoingLinksMethodNameSuffix())»«ENDDEFINE»

«DEFINE linkGetterName(String suffix) FOR gmfgen::GenCommonBase»get«getUniqueIdentifier()»«suffix»Links«ENDDEFINE»

«DEFINE getContainedLinks FOR gmfgen::GenCommonBase-»
	«EXPAND getConnectedLinks(getContainedLinks(getTypeModelFacet(this), getDiagram()), getContainedLinksMethodNameSuffix(), false)-»
«ENDDEFINE»

«DEFINE getIncomingLinks FOR gmfgen::GenCommonBase-»
	«EXPAND getConnectedLinks(getIncomingLinks(getTypeModelFacet(this), getDiagram()), getIncomingLinksMethodNameSuffix(), true)-»
«ENDDEFINE»

«DEFINE getOutgoingLinks FOR gmfgen::GenCommonBase-»
	«EXPAND getConnectedLinks(getOutgoingLinks(getTypeModelFacet(this), getDiagram()), getOutgoingLinksMethodNameSuffix(), false)-»
«ENDDEFINE»

«DEFINE getConnectedLinks(List[gmfgen::GenLink] genLinks, String methodNameSuffix, boolean needCrossReferencer) FOR gmfgen::GenCommonBase-»

	«EXPAND xpt::Common::generatedMemberComment»
public static java.util.List «EXPAND linkGetterName(methodNameSuffix)»(org.eclipse.gmf.runtime.notation.View view) {
	«IF !genLinks.isEmpty()-»
		«LET getTypeModelFacet(this).metaClass AS metaclass-»
	«getQualifiedInterfaceName(metaclass)» modelElement = («getQualifiedInterfaceName(metaclass)») view.getElement();
			«IF needCrossReferencer-»
	java.util.Map crossReferences = org.eclipse.emf.ecore.util.EcoreUtil.CrossReferencer.find(view.eResource().getResourceSet().getResources());
			«ENDIF-»
	java.util.List result = new java.util.LinkedList();
			«EXPAND colectConnnectedLinks(methodNameSuffix, needCrossReferencer, metaclass.isExternalInterface()) FOREACH genLinks-»
	return result;
		«ENDLET-»
	«ELSE-»
	return java.util.Collections.EMPTY_LIST;
	«ENDIF-»
}
«ENDDEFINE»

«DEFINE colectConnnectedLinks(String methodNameSuffix, boolean needCrossReferencer, boolean isExternalInterface) FOR gmfgen::GenLink-»
	«IF isExternalInterface-»
if (modelElement instanceof «EXPAND getLinkEndType(methodNameSuffix) FOR modelFacet») {
	«ENDIF-»
	result.addAll(«EXPAND chooseConnnectedLinksByTypeMethodName(methodNameSuffix, this) FOR modelFacet»(«EXPAND castLinkObject(methodNameSuffix, isExternalInterface) FOR modelFacet»modelElement«IF needCrossReferencer», crossReferences«ENDIF»));	
	«IF isExternalInterface-»
}
	«ENDIF-»
«ENDDEFINE»

«DEFINE castLinkObject(String methodNameSuffix, boolean isExternalInterface) FOR gmfgen::LinkModelFacet»«IF isExternalInterface»(«EXPAND getLinkEndType(methodNameSuffix)») «ENDIF»«ENDDEFINE»

«DEFINE getLinkEndType(String methodNameSuffix) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«REM»
	For FeatureModelFacet-based links we are calling 
	getOutgoing???Links instead of getContained???Links
«ENDREM»
«DEFINE getLinkEndType(String methodNameSuffix) FOR gmfgen::FeatureLinkModelFacet-»
«IF getIncomingLinksMethodNameSuffix() == methodNameSuffix-»
«getQualifiedInterfaceName(getTargetType())»«ELSE-»
«getQualifiedInterfaceName(getSourceType())»«ENDIF-»
«ENDDEFINE»

«REM»
	For TypeModelFacet-based links we are calling 
	getContained???Links instead of getOutgoinf???Links 
	if sourceMetaFeature was not specified
«ENDREM»
«DEFINE getLinkEndType(String methodNameSuffix) FOR gmfgen::TypeLinkModelFacet-»
«IF getIncomingLinksMethodNameSuffix() == methodNameSuffix-»
«getQualifiedInterfaceName(getTargetType())»«ELSEIF getOutgoingLinksMethodNameSuffix() == methodNameSuffix && null != sourceMetaFeature-»
«getQualifiedInterfaceName(getSourceType())»«ELSE-»
«getQualifiedInterfaceName(containmentMetaFeature.genClass)»«ENDIF-»
«ENDDEFINE»

«DEFINE chooseConnnectedLinksByTypeMethodName(String methodNameSuffix, gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«REM»
	For FeatureModelFacet-based links we are calling 
	getOutgoing???Links instead of getContained???Links
«ENDREM»
«DEFINE chooseConnnectedLinksByTypeMethodName(String methodNameSuffix, gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet-»
«IF getContainedLinksMethodNameSuffix() == methodNameSuffix»«EXPAND getConnnectedLinksByTypeMethodName(getOutgoingLinksMethodNameSuffix()) FOR genLink-»
«ELSE»«EXPAND getConnnectedLinksByTypeMethodName(methodNameSuffix) FOR genLink-»
«ENDIF-»
«ENDDEFINE»

«REM»
	For TypeModelFacet-based links we are calling 
	getContained???Links instead of getOutgoinf???Links 
	if sourceMetaFeature was not specified
«ENDREM»
«DEFINE chooseConnnectedLinksByTypeMethodName(String methodNameSuffix, gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
«IF getOutgoingLinksMethodNameSuffix() == methodNameSuffix && null == sourceMetaFeature»«EXPAND getConnnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink-»
«ELSE»«EXPAND getConnnectedLinksByTypeMethodName(methodNameSuffix) FOR genLink-»
«ENDIF-»
«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethod FOR gmfgen::GenLink»«EXPAND getContainedLinksByTypeMethod(this) FOR modelFacet»«ENDDEFINE»

«DEFINE getConnnectedLinksByTypeMethodName(String suffix) FOR gmfgen::GenLink»get«suffix»«EXPAND getConnectedLinksByTypeMethodFragment FOR modelFacet»_«visualID»«ENDDEFINE»

«DEFINE getConnectedLinksByTypeMethodFragment FOR gmfgen::TypeLinkModelFacet»TypeModelFacetLinks_«metaClass.ecoreClass.name»«ENDDEFINE»

«DEFINE getConnectedLinksByTypeMethodFragment FOR gmfgen::FeatureLinkModelFacet»FeatureModelFacetLinks_«getFeatureAccessorName(metaFeature)»«ENDDEFINE»

«DEFINE getConnectedLinksByTypeMethodFragment FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet»«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»

	«EXPAND xpt::Common::generatedMemberComment»
private static java.util.Collection «EXPAND getConnnectedLinksByTypeMethodName(getContainedLinksMethodNameSuffix()) FOR genLink»(«getQualifiedInterfaceName(containmentMetaFeature.genClass)» container) {
	«EXPAND getContainedLinksByTypeMethodBody(genLink, false)-»
}
«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethodBody(gmfgen::GenLink genLink, boolean sourceVarDefined) FOR gmfgen::TypeLinkModelFacet-»
java.util.Collection result = new java.util.LinkedList();
	«LET childMetaFeature.isListType() AS inLoop-»
		«IF inLoop-»
for (java.util.Iterator links = «EXPAND xpt::Common::getFeatureValue("container", containmentMetaFeature.genClass) FOR childMetaFeature».iterator(); links.hasNext();) {
	Object linkObject = links.next();
			«EXPAND defineLink(inLoop)-»
		«ELSE-»
			«IF getTypeGenClassX(childMetaFeature) == metaClass-»
«getQualifiedInterfaceName(metaClass)» link = «EXPAND xpt::Common::getFeatureValue("container", getSourceType()) FOR childMetaFeature»;
			«ELSE-»
«getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))» linkObject = «EXPAND xpt::Common::getFeatureValue("container", getSourceType()) FOR childMetaFeature»;
				«EXPAND defineLink(inLoop)-»
			«ENDIF-»
		«ENDIF-»
		«EXPAND checkLinkVisualID(genLink, inLoop)-»
		«EXPAND defineLinkDestination(inLoop)-»
		«IF null != sourceMetaFeature-»
			«EXPAND defineLinkSource(inLoop)-»
			«IF sourceVarDefined-»
				«EXPAND checkLinkSource(inLoop)-»
			«ENDIF-»
			«EXPAND addLinkDescriptor(genLink, "src", "dst")-»
		«ELSE-»
			«EXPAND addLinkDescriptor(genLink, "container", "dst")-»
		«ENDIF-»
		«IF inLoop-»
}
		«ENDIF-»
	«ENDLET-»
return result;	
«ENDDEFINE»

«DEFINE addLinkDescriptor(gmfgen::GenLink genLink, String srcVar, String dstVar) FOR gmfgen::TypeLinkModelFacet-»
result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getSourceType()»«srcVar», «EXPAND xpt::Common::castToEObject FOR getTargetType()»«dstVar», «EXPAND xpt::Common::castToEObject FOR metaClass»link, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink»));
«ENDDEFINE»

«DEFINE checkLinkVisualID(gmfgen::GenLink genLink, boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
if («EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink» != «EXPAND xpt::editor::VisualIDRegistry::getLinkWithClassVisualIDMethodCall FOR genLink.getDiagram()»(«EXPAND xpt::Common::castToEObject FOR metaClass»link)) {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«ENDDEFINE»

«DEFINE defineLink(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
if (false == linkObject instanceof «getQualifiedInterfaceName(metaClass)») {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«getQualifiedInterfaceName(metaClass)» link = («getQualifiedInterfaceName(metaClass)») linkObject;
«ENDDEFINE»

«DEFINE defineLinkSource(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
	«IF sourceMetaFeature.isListType()-»
java.util.List sources = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR sourceMetaFeature»;
Object theSource = sources.size() == 1 ? sources.get(0) : null;
if (false == theSource instanceof «getQualifiedInterfaceName(getSourceType())») {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«getQualifiedInterfaceName(getSourceType())» src = («getQualifiedInterfaceName(getSourceType())») theSource;
	«ELSE-»
«getQualifiedInterfaceName(getSourceType())» src = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR sourceMetaFeature»;
	«ENDIF-»
«ENDDEFINE»

«DEFINE checkLinkSource(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
if (src != source) {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«ENDDEFINE»

«DEFINE defineLinkDestination(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
	«IF targetMetaFeature.isListType()-»
java.util.List targets = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR targetMetaFeature»;
Object theTarget = targets.size() == 1 ? targets.get(0) : null;
if (false == theTarget instanceof «getQualifiedInterfaceName(getTargetType())») {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«getQualifiedInterfaceName(getTargetType())» dst = («getQualifiedInterfaceName(getTargetType())») theTarget;
	«ELSE-»
«getQualifiedInterfaceName(getTargetType())» dst = «EXPAND xpt::Common::getFeatureValue("link", metaClass) FOR targetMetaFeature»;
	«ENDIF-»
«ENDDEFINE»

«DEFINE stopLinkProcessing(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
«IF inLoop-»
continue;
«ELSE-»
return result;
«ENDIF-»
«ENDDEFINE»

«DEFINE getIncomingLinksByTypeMethod FOR gmfgen::GenLink-»

	«EXPAND xpt::Common::generatedMemberComment»
private static java.util.Collection «EXPAND getConnnectedLinksByTypeMethodName(getIncomingLinksMethodNameSuffix())»(«getQualifiedInterfaceName(modelFacet.getTargetType())» target, java.util.Map crossReferences) {
	java.util.Collection result = new java.util.LinkedList();
	java.util.Collection settings = (java.util.Collection) crossReferences.get(target);
	for (java.util.Iterator it = settings.iterator(); it.hasNext();) {
		org.eclipse.emf.ecore.EStructuralFeature.Setting setting = (org.eclipse.emf.ecore.EStructuralFeature.Setting) it.next();
		«EXPAND getIncomingLinksByTypeMethodBody(this) FOR modelFacet-»
	}
	return result;	
}
«ENDDEFINE»

«DEFINE getIncomingLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
if (setting.getEStructuralFeature() != «EXPAND xpt::Common::metaFeatureAccessor FOR targetMetaFeature» || false == setting.getEObject() instanceof «getQualifiedInterfaceName(metaClass)») {
	continue;
}
«getQualifiedInterfaceName(metaClass)» link = («getQualifiedInterfaceName(metaClass)») setting.getEObject();
	«EXPAND checkLinkVisualID(genLink, true)-»
	«IF null != sourceMetaFeature-»
		«EXPAND defineLinkSource(true)-»
		«EXPAND addLinkDescriptor(genLink, "src", "target")-»
	«ELSE-»
		«EXPAND defineLinkContainer(true)-»
		«EXPAND addLinkDescriptor(genLink, "container", "target")-»
«REM»TODO: continue here.«ENDREM»
	«ENDIF-»
«ENDDEFINE»

«DEFINE defineLinkContainer(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
if (false == «IF metaClass.isExternalInterface()»((org.eclipse.emf.ecore.EObject) «ENDIF»link«IF metaClass.isExternalInterface()»)«ENDIF».eContainer() instanceof «getQualifiedInterfaceName(containmentMetaFeature.genClass)») {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«getQualifiedInterfaceName(containmentMetaFeature.genClass)» container = («getQualifiedInterfaceName(containmentMetaFeature.genClass)») «IF metaClass.isExternalInterface()»((org.eclipse.emf.ecore.EObject) «ENDIF»link«IF metaClass.isExternalInterface()»)«ENDIF».eContainer();
«ENDDEFINE»

«DEFINE getIncomingLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet-»
if (setting.getEStructuralFeature() == «EXPAND xpt::Common::metaFeatureAccessor FOR metaFeature») {
	result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(setting.getEObject(), «EXPAND xpt::Common::castToEObject FOR getTargetType()»target, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink»));
}
«ENDDEFINE»

«DEFINE getIncomingLinksByTypeMethodBody(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«DEFINE getOutgoingLinksByTypeMethod FOR gmfgen::GenLink-»
	«EXPAND getOutgoingLinksByTypeMethod(this) FOR modelFacet-»
«ENDDEFINE»

«DEFINE getOutgoingLinksByTypeMethodSignature FOR gmfgen::GenLink»private static java.util.Collection «EXPAND getConnnectedLinksByTypeMethodName(getOutgoingLinksMethodNameSuffix())»(«getQualifiedInterfaceName(modelFacet.getSourceType())» source)«ENDDEFINE»

«DEFINE getOutgoingLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::FeatureLinkModelFacet-»

	«EXPAND xpt::Common::generatedMemberComment»
«EXPAND getOutgoingLinksByTypeMethodSignature FOR genLink» {
	java.util.Collection result = new java.util.LinkedList();
	«IF metaFeature.isListType()-»
	for (java.util.Iterator destinations = «EXPAND xpt::Common::getFeatureValue("source", getSourceType()) FOR metaFeature».iterator(); destinations.hasNext();) {
		«getQualifiedInterfaceName(getTargetType())» destination = («getQualifiedInterfaceName(getTargetType())») destinations.next();
	«ELSE-»
	«getQualifiedInterfaceName(getTargetType())» destination = «EXPAND xpt::Common::getFeatureValue("source", getSourceType()) FOR metaFeature»;
	«ENDIF-»
	result.add(new «genLink.getDiagram().editorGen.diagramUpdater.getLinkDescriptorQualifiedClassName()»(«EXPAND xpt::Common::castToEObject FOR getSourceType()»source, «EXPAND xpt::Common::castToEObject FOR getTargetType()»destination, «genLink.getDiagram().getElementTypesQualifiedClassName()».«genLink.getUniqueIdentifier()», «EXPAND xpt::editor::VisualIDRegistry::visualID FOR genLink»));
	«IF metaFeature.isListType()-»
	}
	«ENDIF-»
	return result;
}
«ENDDEFINE»

«REM»More careful way to find container should be used here then GMF will be modified in accordance«ENDREM»
«DEFINE getOutgoingLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
	«IF null != sourceMetaFeature-»
	
		«EXPAND xpt::Common::generatedMemberComment»
«EXPAND getOutgoingLinksByTypeMethodSignature FOR genLink» {
	«getQualifiedInterfaceName(containmentMetaFeature.genClass)» container = null;
	// Find container element for the link.
	// Climb up by containment hierarchy starting from the source
	// and return the first element that is instance of the container class.
	for (org.eclipse.emf.ecore.EObject element = «EXPAND xpt::Common::castToEObject FOR getSourceType()» source; element != null && container == null; element = element.eContainer()) {
		if (element instanceof «getQualifiedInterfaceName(containmentMetaFeature.genClass)») {
			container = («getQualifiedInterfaceName(containmentMetaFeature.genClass)») element;
		}
	}
	if (container == null) {
		return java.util.Collections.EMPTY_LIST;
	}
		«EXPAND getContainedLinksByTypeMethodBody(genLink, true)-»
}		
	«ENDIF-»
«ENDDEFINE»

«DEFINE getOutgoingLinksByTypeMethod(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«DEFINE incorrectLinkModelFacet FOR gmfgen::LinkModelFacet-»
	«ERROR "Incorrect LinkModelFacet: " + this»
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagramUpdater»«ENDDEFINE»