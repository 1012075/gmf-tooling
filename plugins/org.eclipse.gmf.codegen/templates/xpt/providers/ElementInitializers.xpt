/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 *    Artem Tikhomirov (Borland) - refactored javaInitilizers not to use methods from GMFGen model
 *                               [221347] Got rid of generated interfaces 
 *                               (IObjectInitializer, IFeatureInitializer) and implementation thereof
 */

«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»

«EXTENSION xpt::providers::ElementInitializers»

«DEFINE ElementInitializers FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «providersPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class ElementInitializers {
	«EXPAND Initializers»
	«EXPAND JavaSupport»
	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE Initializers FOR GenDiagram-»
	«EXPAND initMethod FOREACH getAllNodes()-»
	«EXPAND initMethod FOREACH links-»
«ENDDEFINE»

«DEFINE JavaSupport FOR GenDiagram-»
«IF editorGen.expressionProviders != null && !editorGen.expressionProviders.providers.typeSelect(GenJavaExpressionProvider).isEmpty()-»
	«EXPAND xpt::Common::generatedMemberComment»
	static class Java {
		«EXPAND javaInitializer FOREACH getAllNodes()-»
		«EXPAND javaInitializer FOREACH links-»
	}
«ENDIF-»
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»


«REM»
	Definitions of initializer objects.
«ENDREM»

«DEFINE initMethod FOR GenNode»«EXPAND initMethod(this) FOR modelFacet»«ENDDEFINE»
«DEFINE initMethod FOR GenLink»«EXPAND initMethod(this) FOR modelFacet»«ENDDEFINE»

«DEFINE initMethod(GenCommonBase diagramElement) FOR ModelFacet»«ENDDEFINE»

«DEFINE initMethod(GenCommonBase diagramElement) FOR TypeModelFacet-»
«EXPAND initMethod(diagramElement) FOR modelElementInitializer-»
«ENDDEFINE»

«DEFINE initMethod(GenCommonBase diagramElement) FOR GenElementInitializer»«ERROR "No idea how to init using " + this»«ENDDEFINE»

«DEFINE initMethod(GenCommonBase diagramElement) FOR GenFeatureSeqInitializer-»
	«EXPAND xpt::Common::generatedMemberComment»
	public static void init_«diagramElement.getUniqueIdentifier()»(«EXPAND MetaModel::QualifiedClassName FOR elementClass» instance) {
		try {
			«FOREACH initializers AS i»«EXPAND performInit(diagramElement, "instance", elementClass, initializers.indexOf(i)) FOR i»«ENDFOREACH-»
		} catch(RuntimeException e) {
			«diagramElement.getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Element initialization failed", e); //$NON-NLS-1$						
		}
	}
«ENDDEFINE»

«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, int count) FOR GenFeatureInitializer»«ENDDEFINE»

«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, int count) FOR GenFeatureValueSpec-»
	Object value«count» = «EXPAND evaluateExpr(this, instanceVar) FOR diagramElement.getDiagram().editorGen.expressionProviders.getProvider(this)»;
«IF isListType(feature)-»
	if (value«count» instanceof java.util.Collection) {
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».clear();
«IF expressionResultNeedsCast(getTypeGenClassifier(feature))-»
		for (java.util.Iterator it = ((java.util.Collection) value«count»).iterator(); it.hasNext(); ) {
			Object next = «diagramElement.getDiagram().editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()».performCast(it.next(), «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
			«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».add(next);
		}
«ELSE-»
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».addAll(((java.util.Collection) value«count»));
«ENDIF-»
	} else {
«IF expressionResultNeedsCast(getTypeGenClassifier(feature))-»
		value«count» = «diagramElement.getDiagram().editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()».performCast(value«count», «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
«ENDIF-»
		«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass, true) FOR feature».add(value«count»);
	}
«ELSE-»
«IF expressionResultNeedsCast(getTypeGenClassifier(feature))»
	value«count» = «diagramElement.getDiagram().editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()».performCast(value«count», «EXPAND MetaModel::MetaClass FOR getTypeGenClassifier(feature)»);
«ENDIF-»
	«EXPAND MetaModel::setFeatureValue(instanceVar, instanceClass, "value" + count, true) FOR feature»;
«ENDIF /*isListType*/-»
«ENDDEFINE»

«DEFINE performInit(GenCommonBase diagramElement, String instanceVar, GenClass instanceClass, int count) FOR GenReferenceNewElementSpec-»
«FOREACH newElementInitializers AS newElemInit»
«EXPAND MetaModel::NewInstance("newInstance" + count) FOR newElemInit.elementClass»
«IF isListType(feature)-»
«EXPAND MetaModel::getFeatureValue(instanceVar, instanceClass) FOR feature».add(newInstance«count»);
«ELSE-»
«EXPAND MetaModel::setFeatureValue(instanceVar, instanceClass, "newInstance" + count) FOR feature»;
«ENDIF-»
«FOREACH newElemInit.initializers AS i»«EXPAND performInit(diagramElement, "newInstance" + count, newElemInit.elementClass, (count+1)*100 + newElemInit.initializers.indexOf(i)) FOR i»«ENDFOREACH-»
«ENDFOREACH-»
«ENDDEFINE»


/////////////////////////////////

«DEFINE evaluateExpr(GenFeatureValueSpec valueExpr, String instanceVar) FOR GenExpressionProviderBase»«ENDDEFINE»

// XXX perhaps, using instance.eClass() is better option than MetaModel::MetaClass (though, need to rely on instance variable name/type) 
«DEFINE evaluateExpr(GenFeatureValueSpec valueExpr, String instanceVar) FOR GenExpressionInterpreter-»
«EXPAND xpt::expressions::getExpression::getExpression(valueExpr, valueExpr.featureSeqInitializer.elementClass)».evaluate(«instanceVar»)«-»
«ENDDEFINE»

«DEFINE evaluateExpr(GenFeatureValueSpec valueExpr, String instanceVar) FOR GenJavaExpressionProvider-»
Java.«getOperationName(valueExpr)»(«instanceVar»)«-»
«ENDDEFINE»


«REM»
	Definitions of Java initialization methods.
«ENDREM»

«DEFINE javaInitializer FOR GenNode»«EXPAND javaInitializer(this) FOR modelFacet»«ENDDEFINE»
«DEFINE javaInitializer FOR GenLink»«EXPAND javaInitializer(this) FOR modelFacet»«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR ModelFacet»«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR TypeModelFacet-»
«EXPAND javaInitializer(diagramElement) FOR modelElementInitializer-»
«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR GenElementInitializer»«ENDDEFINE»

«DEFINE javaInitializer(GenCommonBase diagramElement) FOR GenFeatureSeqInitializer-»
«FOREACH diagramElement.getDiagram().editorGen.expressionProviders.providers.typeSelect(GenJavaExpressionProvider) AS jp-»
«FOREACH getFeatureInitializers(this, jp) AS valueExpression-»
«EXPAND xpt::Common::generatedMemberComment»
private static «EXPAND MetaModel::featureTargetType FOR valueExpression.feature» «jp.getOperationName(valueExpression)»(«EXPAND MetaModel::QualifiedClassName FOR valueExpression.featureSeqInitializer.elementClass» self) {
	// TODO: implement this method to return value  
	// for «EXPAND MetaModel::MetaFeature FOR valueExpression.feature»
	// Ensure that you remove @generated or mark it @generated NOT
	/* Expression body:
	   «valueExpression.body»
	 */
	
	throw new «jp.container.getAbstractExpressionQualifiedClassName()».NoImplException("No user java implementation provided in '«jp.getOperationName(valueExpression)»' operation"); «EXPAND xpt::Common::nonNLS»
}
«ENDFOREACH-»
«ENDFOREACH-»
«ENDDEFINE»