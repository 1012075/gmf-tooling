package org.eclipse.gmf.codegen.templates.parts;

import org.eclipse.gmf.codegen.gmfgen.*;

public class TextDirectEditManagerGenerator
{
  protected static String nl;
  public static synchronized TextDirectEditManagerGenerator create(String lineSeparator)
  {
    nl = lineSeparator;
    TextDirectEditManagerGenerator result = new TextDirectEditManagerGenerator();
    nl = null;
    return result;
  }

  protected final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "";
  protected final String TEXT_2 = NL + "/*" + NL + " * ";
  protected final String TEXT_3 = NL + " */";
  protected final String TEXT_4 = NL + "package ";
  protected final String TEXT_5 = ";" + NL + "" + NL + "import org.eclipse.draw2d.FigureUtilities;" + NL + "import org.eclipse.draw2d.IFigure;" + NL + "import org.eclipse.draw2d.Label;" + NL + "import org.eclipse.draw2d.geometry.Dimension;" + NL + "import org.eclipse.draw2d.geometry.Rectangle;" + NL + "import org.eclipse.gef.GraphicalEditPart;" + NL + "import org.eclipse.gef.tools.CellEditorLocator;" + NL + "import org.eclipse.gef.tools.DirectEditManager;" + NL + "import org.eclipse.gmf.runtime.common.ui.contentassist.ContentAssistantHelper;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramFontRegistry;" + NL + "import org.eclipse.gmf.runtime.draw2d.ui.figures.WrapLabel;" + NL + "import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;" + NL + "import org.eclipse.gmf.runtime.gef.ui.internal.parts.TextCellEditorEx;" + NL + "import org.eclipse.gmf.runtime.gef.ui.internal.parts.WrapTextCellEditor;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;" + NL + "import org.eclipse.jface.util.Assert;" + NL + "import org.eclipse.jface.viewers.CellEditor;" + NL + "import org.eclipse.swt.SWT;" + NL + "import org.eclipse.swt.graphics.Color;" + NL + "import org.eclipse.swt.graphics.Font;" + NL + "import org.eclipse.swt.graphics.FontData;" + NL + "import org.eclipse.swt.graphics.Point;" + NL + "import org.eclipse.swt.graphics.RGB;" + NL + "import org.eclipse.swt.widgets.Control;" + NL + "import org.eclipse.swt.widgets.Display;" + NL + "import org.eclipse.swt.widgets.Event;" + NL + "import org.eclipse.swt.widgets.Shell;" + NL + "import org.eclipse.swt.widgets.Table;" + NL + "import org.eclipse.swt.widgets.Text;" + NL + "" + NL + "/**" + NL + " * @generated" + NL + " */" + NL + "public class TextDirectEditManager extends DirectEditManager {" + NL + "\t" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprivate Color proposalPopupBackgroundColor = null;" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprivate Color proposalPopupForegroundColor = null;" + NL + "\t" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprivate boolean committed = false;" + NL + "\t" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprivate boolean listenersAttached = true;" + NL + "\t" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tstatic private class WrapTextCellEditorLocator implements CellEditorLocator {" + NL + "" + NL + "\t\tprivate WrapLabel wrapLabel;" + NL + "\t\t" + NL + "\t\tpublic WrapTextCellEditorLocator(WrapLabel wrapLabel) {" + NL + "\t\t\tsuper();" + NL + "\t\t\tthis.wrapLabel = wrapLabel;" + NL + "\t\t}" + NL + "" + NL + "\t\t" + NL + "\t\tpublic WrapLabel getWrapLabel() {" + NL + "\t\t\treturn wrapLabel;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic void relocate(CellEditor celleditor) {" + NL + "\t\t\tText text = (Text) celleditor.getControl();" + NL + "\t\t\tRectangle rect = getWrapLabel().getTextBounds().getCopy();" + NL + "\t\t\tgetWrapLabel().translateToAbsolute(rect);" + NL + "\t\t\t" + NL + "\t\t\tif (getWrapLabel().isTextWrapped() && getWrapLabel().getText().length() > 0)" + NL + "\t\t\t\trect.setSize(new Dimension(text.computeSize(rect.width, SWT.DEFAULT)));" + NL + "\t\t\telse {" + NL + "\t\t\t\tint avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();" + NL + "\t\t\t\trect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr*2, 0));" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\tif (!rect.equals(new Rectangle(text.getBounds())))" + NL + "\t\t\t\ttext.setBounds(rect.x, rect.y, rect.width, rect.height);" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tstatic private class TextCellEditorLocator implements CellEditorLocator {" + NL + "" + NL + "\t\tprivate Label label;" + NL + "" + NL + "\t\tpublic TextCellEditorLocator(Label label) {" + NL + "\t\t\tsuper();" + NL + "\t\t\tthis.label = label;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic Label getLabel() {" + NL + "\t\t\treturn label;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic void relocate(CellEditor celleditor) {" + NL + "\t\t\tText text = (Text) celleditor.getControl();" + NL + "\t\t\tRectangle rect = getLabel().getTextBounds().getCopy();" + NL + "\t\t\tgetLabel().translateToAbsolute(rect);" + NL + "" + NL + "\t\t\tint avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();" + NL + "\t\t\trect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr * 2, 0));" + NL + "" + NL + "\t\t\tif (!rect.equals(new Rectangle(text.getBounds())))" + NL + "\t\t\t\ttext.setBounds(rect.x, rect.y, rect.width, rect.height);" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic TextDirectEditManager(ITextAwareEditPart source) {" + NL + "\t\tsuper(source, getTextCellEditorClass(source), getCellEditorLocator(source.getFigure()));" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic TextDirectEditManager(GraphicalEditPart source, Class editorType, CellEditorLocator locator) {" + NL + "\t\tsuper(source, editorType, locator);\t\t" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprivate static CellEditorLocator getCellEditorLocator(IFigure label) {" + NL + "\t\tif (label instanceof Label) {" + NL + "\t\t\treturn new TextCellEditorLocator((Label) label);" + NL + "\t\t}" + NL + "\t\treturn new WrapTextCellEditorLocator((WrapLabel) label);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprivate static Class getTextCellEditorClass(ITextAwareEditPart source) {" + NL + "\t\tIFigure label = source.getFigure();" + NL + "" + NL + "\t\tif (label instanceof WrapLabel && ((WrapLabel) label).isTextWrapped())" + NL + "\t\t\treturn WrapTextCellEditor.class;" + NL + "" + NL + "\t\treturn TextCellEditorEx.class;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected Font getScaledFont(IFigure label) {" + NL + "\t\tFont scaledFont = label.getFont();" + NL + "\t\tFontData data = scaledFont.getFontData()[0];" + NL + "\t\tDimension fontSize = new Dimension(0, MapModeUtil.getMapMode(label).DPtoLP(data.getHeight()));" + NL + "\t\tlabel.translateToAbsolute(fontSize);" + NL + "\t\t" + NL + "\t\tif( Math.abs( data.getHeight() - fontSize.height ) < 2 )" + NL + "\t\t\tfontSize.height = data.getHeight();" + NL + "" + NL + "\t\tdata.setHeight(fontSize.height);" + NL + "\t\tFont newFont = DiagramFontRegistry.getInstance().getFont(null, data);" + NL + "\t\treturn newFont;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void initCellEditor() {" + NL + "\t\tcommitted = false;" + NL + "" + NL + "\t\t// Get the Text Compartments Edit Part" + NL + "\t\tITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();" + NL + "" + NL + "\t\tsetEditText(textEP.getEditText());" + NL + "" + NL + "\t\tIFigure label = textEP.getFigure();" + NL + "\t\tAssert.isNotNull(label);" + NL + "\t\tText text = (Text) getCellEditor().getControl();" + NL + "\t\t// scale the font accordingly to the zoom level" + NL + "\t\ttext.setFont(getScaledFont(label));" + NL + "\t\t" + NL + "\t\t" + NL + "\t\t// register a validator on the cell editor" + NL + "\t\tgetCellEditor().setValidator(textEP.getEditTextValidator());" + NL + "" + NL + "\t\tif (textEP.getParser() != null) {" + NL + "\t\t\tIContentAssistProcessor processor = textEP.getCompletionProcessor();" + NL + "\t\t\tif (processor != null) {" + NL + "\t\t\t\t// register content assist" + NL + "\t\t\t\tproposalPopupBackgroundColor = new Color(getCellEditor()" + NL + "\t\t\t\t\t.getControl().getShell().getDisplay(), new RGB(254, 241," + NL + "\t\t\t\t\t233));" + NL + "\t\t\t\tproposalPopupForegroundColor = new Color(getCellEditor()" + NL + "\t\t\t\t\t.getControl().getShell().getDisplay(), new RGB(0, 0, 0));" + NL + "" + NL + "\t\t\t\tContentAssistantHelper.createTextContentAssistant(text," + NL + "\t\t\t\t\tproposalPopupForegroundColor, proposalPopupBackgroundColor," + NL + "\t\t\t\t\tprocessor);" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void commit() {" + NL + "\t\tShell activeShell = Display.getCurrent().getActiveShell();" + NL + "\t\tif (activeShell != null" + NL + "\t\t\t&& getCellEditor().getControl().getShell().equals(" + NL + "\t\t\t\tactiveShell.getParent())) {" + NL + "\t\t\tControl[] children = activeShell.getChildren();" + NL + "\t\t\tif (children.length == 1 && children[0] instanceof Table) {" + NL + "\t\t\t\t/*" + NL + "\t\t\t\t * CONTENT ASSIST: focus is lost to the content assist pop up -" + NL + "\t\t\t\t * stay in focus" + NL + "\t\t\t\t */" + NL + "\t\t\t\tgetCellEditor().getControl().setVisible(true);" + NL + "\t\t\t\t((TextCellEditorEx) getCellEditor()).setDeactivationLock(true);" + NL + "\t\t\t\treturn;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t\t// content assist hacks" + NL + "\t\tif (committed) {" + NL + "\t\t\tbringDown();" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tcommitted = true;" + NL + "\t\tsuper.commit();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void bringDown() {" + NL + "\t\tif (proposalPopupForegroundColor != null) {" + NL + "\t\t\tproposalPopupForegroundColor.dispose();" + NL + "\t\t\tproposalPopupForegroundColor = null;" + NL + "\t\t}" + NL + "\t\tif (proposalPopupBackgroundColor != null) {" + NL + "\t\t\tproposalPopupBackgroundColor.dispose();" + NL + "\t\t\tproposalPopupBackgroundColor = null;" + NL + "\t\t}" + NL + "" + NL + "\t\t// myee - RATLC00523014: crashes when queued in asyncExec()" + NL + "\t\teraseFeedback();" + NL + "\t\t" + NL + "\t\tDisplay.getCurrent().asyncExec(new Runnable() {" + NL + "" + NL + "\t\t\tpublic void run() {" + NL + "\t\t\t\t// Content Assist hack - allow proper cleanup on childen" + NL + "\t\t\t\t// controls" + NL + "\t\t\t\tTextDirectEditManager.super.bringDown();" + NL + "\t\t\t}" + NL + "\t\t});" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic void setEditText(String toEdit) {" + NL + "" + NL + "\t\t// Get the cell editor" + NL + "\t\tCellEditor cellEditor = getCellEditor();" + NL + "" + NL + "\t\t// IF the cell editor doesn't exist yet..." + NL + "\t\tif (cellEditor == null) {" + NL + "\t\t\t// Do nothing" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "" + NL + "\t\t// Get the Text Compartment Edit Part" + NL + "\t\tITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();" + NL + "" + NL + "\t\t// Get the Text control" + NL + "\t\tText textControl = (Text) cellEditor.getControl();" + NL + "" + NL + "\t\t// Get the Text Edit Part's Figure (WrapLabel)" + NL + "\t\tIFigure label = textEP.getFigure();" + NL + "\t\tAssert.isNotNull(label);" + NL + "\t\t// Set the Figures text" + NL + "\t\tif (label instanceof Label) {" + NL + "\t\t\t((Label) label).setText(toEdit);" + NL + "\t\t} else {" + NL + "\t\t\t((WrapLabel) label).setText(toEdit);" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\t// See RATLC00522324" + NL + "\t\tif (cellEditor instanceof TextCellEditorEx){" + NL + "\t\t\t((TextCellEditorEx)cellEditor).setValueAndProcessEditOccured(toEdit);" + NL + "\t\t} else {" + NL + "\t\t\tcellEditor.setValue(toEdit);" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\t// Set the controls text and position the caret at the end of the text" + NL + "\t\ttextControl.setSelection(toEdit.length());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic void show(char initialChar) {" + NL + "\t\t" + NL + "\t\tshow();" + NL + "\t\t// Set the cell editor text to the initial character" + NL + "\t\tString initialString = String.valueOf(initialChar);" + NL + "\t\tsetEditText(initialString);" + NL + "" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic void show(Point location) {\t\t" + NL + "\t\tshow();" + NL + "\t\tsendMouseClick(location);\t" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprivate void sendMouseClick(Point location) {\t\t" + NL + "\t\t" + NL + "\t\tfinal Display currDisplay = Display.getCurrent();" + NL + "\t\tfinal Point currLocation = location;" + NL + "\t\tnew Thread() {" + NL + "\t\t\tEvent event;" + NL + "\t\t\tpublic void run() {" + NL + "\t\t\t\t\tevent = new Event();" + NL + "\t\t\t\t\tevent.type = SWT.MouseDown;" + NL + "\t\t\t\t\tevent.button = 1;" + NL + "\t\t\t\t\tevent.x = currLocation.x;" + NL + "\t\t\t\t\tevent.y = currLocation.y;" + NL + "\t\t\t\t\tcurrDisplay.post(event);" + NL + "\t\t\t\t\tevent.type = SWT.MouseUp;" + NL + "\t\t\t\t\tcurrDisplay.post(event);" + NL + "\t\t\t}" + NL + "\t\t}.start();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void unhookListeners() {" + NL + "\t\tif (listenersAttached) {" + NL + "\t\t\tlistenersAttached = false;" + NL + "\t\t\tsuper.unhookListeners();" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void setCellEditor(CellEditor editor) {" + NL + "\t\tsuper.setCellEditor(editor);" + NL + "\t\tif (editor != null) {" + NL + "\t\t\tlistenersAttached = true;" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic void showFeedback() {" + NL + "\t\ttry {" + NL + "\t\t\tgetEditPart().getRoot();" + NL + "\t\t\tsuper.showFeedback();" + NL + "\t\t} catch (Exception e) {" + NL + "\t\t\t// TODO: handle exception" + NL + "\t\t}\t" + NL + "\t}" + NL + "}";
  protected final String TEXT_6 = NL;

  public String generate(Object argument)
  {
    StringBuffer stringBuffer = new StringBuffer();
    
GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];

    stringBuffer.append(TEXT_1);
    
String copyrightText = genDiagram.getEditorGen().getCopyrightText();
if (copyrightText != null && copyrightText.trim().length() > 0) {

    stringBuffer.append(TEXT_2);
    stringBuffer.append(copyrightText.replaceAll("\n", "\n * "));
    stringBuffer.append(TEXT_3);
    }
    stringBuffer.append(TEXT_4);
    stringBuffer.append(genDiagram.getEditPartsPackageName());
    stringBuffer.append(TEXT_5);
    stringBuffer.append(TEXT_6);
    return stringBuffer.toString();
  }
}
