package org.eclipse.gmf.codegen.templates.editor;

import org.eclipse.gmf.codegen.gmfgen.*;
import org.eclipse.gmf.common.codegen.*;

public class DocumentProviderGenerator
{
  protected static String nl;
  public static synchronized DocumentProviderGenerator create(String lineSeparator)
  {
    nl = lineSeparator;
    DocumentProviderGenerator result = new DocumentProviderGenerator();
    nl = null;
    return result;
  }

  protected final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "";
  protected final String TEXT_2 = NL + "/*" + NL + " *";
  protected final String TEXT_3 = NL + " */";
  protected final String TEXT_4 = NL;
  protected final String TEXT_5 = NL + NL + "/**" + NL + " * @generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_6 = " extends StorageDocumentProvider implements IDiagramDocumentProvider {" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprivate final String myContentObjectURI;" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_7 = "() {" + NL + "\t\tthis(null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_8 = "(String rootObjectURI) {" + NL + "\t\tmyContentObjectURI = rootObjectURI;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected ElementInfo createElementInfo(Object element) throws CoreException {" + NL + "\t\tif (false == element instanceof FileEditorInputProxy) {" + NL + "\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ";
  protected final String TEXT_9 = ".ID, 0, \"Incorrect element used: \" + element + \" instead of FileEditorInputProxy\", null));" + NL + "\t\t}" + NL + "\t\tFileEditorInputProxy editorInput = (FileEditorInputProxy) element;" + NL + "\t\tIDiagramDocument document = (IDiagramDocument) createDocument(editorInput);" + NL + "" + NL + "\t\tResourceSetInfo info = new ResourceSetInfo(document, editorInput);" + NL + "\t\tinfo.setModificationStamp(computeModificationStamp(info));" + NL + "\t\tinfo.fStatus = null;" + NL + "\t\tResourceSetModificationListener modificationListener = new ResourceSetModificationListener(info);" + NL + "\t\tinfo.getResourceSet().eAdapters().add(modificationListener);" + NL + "\t\treturn info;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprivate long computeModificationStamp(ResourceSetInfo info) {" + NL + "\t\tint result = 0;" + NL + "\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\tif (file != null) {" + NL + "\t\t\t\tif (file.getLocation() != null) {" + NL + "\t\t\t\t\tresult += file.getModificationStamp();" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tresult += file.getLocation().toFile().lastModified();" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn result;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected IDocument createEmptyDocument() {" + NL + "\t\treturn new DiagramDocument();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected boolean setDocumentContent(IDocument document, IEditorInput editorInput) throws CoreException {" + NL + "\t\tif (editorInput instanceof FileEditorInputProxy && document instanceof IDiagramDocument) {" + NL + "\t\t\tFileEditorInputProxy editorInputProxy = (FileEditorInputProxy) editorInput;" + NL + "\t\t\tIDiagramDocument diagramDocument = (IDiagramDocument) document;" + NL + "\t\t\tdiagramDocument.setEditingDomain(editorInputProxy.getEditingDomain());" + NL + "\t\t}" + NL + "\t\treturn super.setDocumentContent(document, editorInput);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void setDocumentContentFromStorage(IDocument document, IStorage storage) throws CoreException {" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument) document;" + NL + "\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tdiagram = DiagramIOUtil.load(domain, storage, true, getProgressMonitor());" + NL + "\t\tif (myContentObjectURI != null && diagram != null && diagram.eResource() != null && !diagram.eResource().getURIFragment(diagram).equals(myContentObjectURI)) {" + NL + "\t\t\tEObject anotherContentObject = diagram.eResource().getEObject(myContentObjectURI);" + NL + "\t\t\tdocument.setContent(anotherContentObject);" + NL + "\t\t} else {" + NL + "\t\t\tdocument.setContent(diagram);" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic long getModificationStamp(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\treturn computeModificationStamp(info);" + NL + "\t\t}" + NL + "\t\treturn super.getModificationStamp(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic long getSynchronizationStamp(Object element) {" + NL + "\t\tif (element instanceof FileEditorInputProxy) {" + NL + "\t\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\t\tif (info != null) {" + NL + "\t\t\t\treturn info.getModificationStamp();" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSynchronizationStamp(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic boolean isDeleted(Object element) {" + NL + "\t\tif (element instanceof IFileEditorInput) {" + NL + "\t\t\tIFileEditorInput input = (IFileEditorInput) element;" + NL + "\t\t\tIPath path = input.getFile().getLocation();" + NL + "\t\t\tif (path == null) {" + NL + "\t\t\t\treturn true;" + NL + "\t\t\t}" + NL + "\t\t\treturn !path.toFile().exists();" + NL + "\t\t}" + NL + "\t\treturn super.isDeleted(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic ResourceSetInfo getResourceSetInfo(Object editorInput) {" + NL + "\t\treturn (ResourceSetInfo) super.getElementInfo(editorInput);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void disposeElementInfo(Object element, ElementInfo info) {" + NL + "\t\tif (info instanceof ResourceSetInfo) {" + NL + "\t\t\tResourceSetInfo resourceSetInfo = (ResourceSetInfo) info;" + NL + "\t\t\tresourceSetInfo.dispose();" + NL + "\t\t}" + NL + "\t\tsuper.disposeElementInfo(element, info);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void doValidateState(Object element, Object computationContext) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection files2Validate = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null && file.isReadOnly()) {" + NL + "\t\t\t\t\tfiles2Validate.add(file);" + NL + "\t\t\t\t}" + NL + "\t\t\t\tIWorkspace workspace = file.getWorkspace();" + NL + "\t\t\t\tworkspace.validateEdit(new IFile[] { file }, computationContext);" + NL + "\t\t\t}" + NL + "\t\t\tResourcesPlugin.getWorkspace().validateEdit((IFile[]) files2Validate.toArray(new IFile[files2Validate.size()]), computationContext);" + NL + "\t\t}" + NL + "" + NL + "\t\tsuper.doValidateState(element, computationContext);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic boolean isModifiable(Object element) {" + NL + "\t\tif (!isStateValidated(element)) {" + NL + "\t\t\tif (element instanceof FileEditorInputProxy) {" + NL + "\t\t\t\treturn true;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.isModifiable(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void updateCache(IStorageEditorInput input) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(input);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null && file.isReadOnly()) {" + NL + "\t\t\t\t\tinfo.fIsReadOnly = true;" + NL + "\t\t\t\t\tinfo.fIsModifiable = false;" + NL + "\t\t\t\t\treturn;" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tinfo.fIsReadOnly = false;" + NL + "\t\t\tinfo.fIsModifiable = true;" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tsuper.updateCache(input);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic boolean isSynchronized(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\treturn info.isSynchronized();" + NL + "\t\t}" + NL + "\t\treturn super.isSynchronized(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getResetRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(ResourcesPlugin.getWorkspace().getRuleFactory().modifyRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(computeSchedulingRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSynchronizeRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(ResourcesPlugin.getWorkspace().getRuleFactory().refreshRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getValidateStateRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection files = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\tfiles.add(file);" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().validateEditRule((IFile[]) files.toArray(new IFile[files.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists())" + NL + "\t\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent = toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t/*" + NL + "\t\t\t * XXX This is a workaround for" + NL + "\t\t\t * https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy" + NL + "\t\t\t * itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify = parent;" + NL + "\t\t\tparent = toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists());" + NL + "" + NL + "\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().createRule(toCreateOrModify);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void doSynchronize(Object element, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null && element instanceof FileEditorInputProxy) {" + NL + "\t\t\thandleResourcesChanged(info, info.getResourceSet().getResources(), monitor);" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tsuper.doSynchronize(element, monitor);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void handleResourcesMoved(Map movedPathToResource) {" + NL + "\t\tfor (Iterator it = movedPathToResource.entrySet().iterator(); it.hasNext();) {" + NL + "\t\t\tEntry nextEntry = (Entry) it.next();" + NL + "\t\t\tIPath newPath = (IPath) nextEntry.getKey();" + NL + "\t\t\tResource resource = (Resource) nextEntry.getValue();" + NL + "\t\t\tresource.setURI(URI.createURI(newPath.toString()));" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void markWholeResourceSetAsDirty(ResourceSet resourceSet) {" + NL + "\t\tfor (Iterator it = resourceSet.getResources().iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tnextResource.setModified(true);" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void handleResourcesChanged(ResourceSetInfo info, Collection changedResources, IProgressMonitor monitor) {" + NL + "\t\tinfo.stopResourceListening();" + NL + "\t\tfor (Iterator it = changedResources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\tif (file != null) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tfile.refreshLocal(IResource.DEPTH_INFINITE, monitor);" + NL + "\t\t\t\t} catch (CoreException e) {" + NL + "\t\t\t\t\thandleCoreException(e, \"FileDocumentProvider.handleElementContentChanged\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tnextResource.unload();" + NL + "\t\t}" + NL + "\t\tinfo.startResourceListening();" + NL + "" + NL + "\t\tfireElementContentAboutToBeReplaced(info.getEditorInput());" + NL + "\t\tremoveUnchangedElementListeners(info.getEditorInput(), info);" + NL + "\t\tinfo.fStatus = null;" + NL + "\t\ttry {" + NL + "\t\t\tsetDocumentContent(info.fDocument, info.getEditorInput());" + NL + "\t\t} catch (CoreException e) {" + NL + "\t\t\tinfo.fStatus = e.getStatus();" + NL + "\t\t}" + NL + "\t\tif (!info.fCanBeSaved) {" + NL + "\t\t\tinfo.setModificationStamp(computeModificationStamp(info));" + NL + "\t\t}" + NL + "\t\taddUnchangedElementListeners(info.getEditorInput(), info);" + NL + "\t\tfireElementContentReplaced(info.getEditorInput());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void doSaveDocument(IProgressMonitor monitor, Object element, IDocument document, boolean overwrite) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tif (!overwrite && !info.isSynchronized()) {" + NL + "\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ";
  protected final String TEXT_10 = ".ID, IResourceStatus.OUT_OF_SYNC_LOCAL, \"The file has been changed on the file system\", null));" + NL + "\t\t\t}" + NL + "\t\t\tinfo.stopResourceListening();" + NL + "\t\t\tfireElementStateChanging(element);" + NL + "\t\t\ttry {" + NL + "\t\t\t\tmonitor.beginTask(\"Saving diagram editor\", info.getResourceSet().getResources().size());" + NL + "\t\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\tmonitor.setTaskName(\"Saving \" + nextResource.getURI());" + NL + "\t\t\t\t\tif (nextResource.isLoaded() && (!nextResource.isTrackingModification() || nextResource.isModified())) {" + NL + "\t\t\t\t\t\tnextResource.save(Collections.EMPTY_MAP);" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\tmonitor.worked(1);" + NL + "\t\t\t\t}" + NL + "\t\t\t\tmonitor.done();" + NL + "\t\t\t} catch (IOException e) {" + NL + "\t\t\t\tfireElementStateChangeFailed(element);" + NL + "\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ";
  protected final String TEXT_11 = ".ID, EditorStatusCodes.RESOURCE_FAILURE, e.getLocalizedMessage(), null));" + NL + "\t\t\t} catch (RuntimeException x) {" + NL + "\t\t\t\tfireElementStateChangeFailed(element);" + NL + "\t\t\t\tthrow x;" + NL + "\t\t\t} finally {" + NL + "\t\t\t\tinfo.startResourceListening();" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\tif (info != null) {" + NL + "\t\t\t\tinfo.setModificationStamp(computeModificationStamp(info));" + NL + "\t\t\t\tinfo.setSynchronized();" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\tsuper.doSaveDocument(monitor, element, document, overwrite);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void handleElementMoved(FileEditorInputProxy input, IPath path) {" + NL + "\t\tIWorkspace workspace = ResourcesPlugin.getWorkspace();" + NL + "\t\tIFile newFile = workspace.getRoot().getFile(path);" + NL + "\t\tfireElementMoved(input, newFile == null ? null : new FileEditorInput(newFile));" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tprotected void handleElementDeleted(FileEditorInputProxy input) {" + NL + "\t\tfireElementDeleted(input);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic IEditorInput createInputWithEditingDomain(IEditorInput editorInput, TransactionalEditingDomain domain) {" + NL + "\t\tif (editorInput instanceof IFileEditorInput) {" + NL + "\t\t\treturn new FileEditorInputProxy((IFileEditorInput) editorInput, domain);" + NL + "\t\t}" + NL + "\t\tassert false;" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */" + NL + "\tpublic IDiagramDocument getDiagramDocument(Object element) {" + NL + "\t\tIDocument doc = getDocument(element);" + NL + "\t\tif (doc instanceof IDiagramDocument) {" + NL + "\t\t\treturn (IDiagramDocument) doc;" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */\t" + NL + "\tprotected class ResourceSetInfo extends StorageInfo {" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t \tprivate long myModificationStamp = IResource.NULL_STAMP;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tprivate ResourceSetSynchronizer mySynchronizer;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tprivate ResourceSet myResourceSet;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tprivate Collection myUnSynchronizedResources = new ArrayList();" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tprivate FileEditorInputProxy myEditorInput;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic ResourceSetInfo(IDiagramDocument document, FileEditorInputProxy editorInput) {" + NL + "\t\t\tsuper(document);" + NL + "\t\t\tmyResourceSet = document.getEditingDomain().getResourceSet();" + NL + "\t\t\tmyEditorInput = editorInput;" + NL + "\t\t\tmySynchronizer = new ResourceSetSynchronizer(this);" + NL + "\t\t\tstartResourceListening();" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic long getModificationStamp() {" + NL + "\t\t\treturn myModificationStamp;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic void setModificationStamp(long modificationStamp) {" + NL + "\t\t\tmyModificationStamp = modificationStamp;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic ResourceSetSynchronizer getSynchronizer() {" + NL + "\t\t\treturn mySynchronizer;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic ResourceSet getResourceSet() {" + NL + "\t\t\treturn myResourceSet;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic FileEditorInputProxy getEditorInput() {" + NL + "\t\t\treturn myEditorInput;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic void dispose() {" + NL + "\t\t\tstopResourceListening();" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic boolean isSynchronized() {" + NL + "\t\t\treturn myUnSynchronizedResources.size() == 0;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic void setSynchronized() {" + NL + "\t\t\tmyUnSynchronizedResources.clear();" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic void setUnSynchronized(Resource resource) {" + NL + "\t\t\tmyUnSynchronizedResources.add(resource);" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic void setSynchronized(Resource resource) {" + NL + "\t\t\tmyUnSynchronizedResources.remove(resource);" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic final void stopResourceListening() {" + NL + "\t\t\tResourcesPlugin.getWorkspace().removeResourceChangeListener(mySynchronizer);" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */" + NL + "\t\tpublic final void startResourceListening() {" + NL + "\t\t\tResourcesPlugin.getWorkspace().addResourceChangeListener(mySynchronizer, IResourceChangeEvent.POST_CHANGE);" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */\t" + NL + "\tprotected class ResourceSetSynchronizer implements IResourceChangeListener {" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */\t" + NL + "\t\tprivate ResourceSetInfo myInfo;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */\t" + NL + "\t\tprotected ResourceSetSynchronizer(ResourceSetInfo info) {" + NL + "\t\t\tmyInfo = info;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */\t" + NL + "\t\tpublic void resourceChanged(IResourceChangeEvent event) {" + NL + "\t\t\tfinal ResourceDeltaVisitor deltaVisitor = new ResourceDeltaVisitor();" + NL + "\t\t\ttry {" + NL + "\t\t\t\tevent.getDelta().accept(deltaVisitor);" + NL + "\t\t\t} catch (CoreException e) {" + NL + "\t\t\t\thandleCoreException(e, \"FileDocumentProvider.resourceChanged\");" + NL + "\t\t\t}" + NL + "\t\t\tsynchronized (myInfo) {" + NL + "\t\t\t\tif (!myInfo.isSynchronized()) {" + NL + "\t\t\t\t\treturn;" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\tDisplay.getDefault().asyncExec(new Runnable() {" + NL + "" + NL + "\t\t\t\tpublic void run() {" + NL + "\t\t\t\t\tif (deltaVisitor.getDeletedResources().size() > 0) {" + NL + "\t\t\t\t\t\t// Just closing editor" + NL + "\t\t\t\t\t\thandleElementDeleted(myInfo.getEditorInput());" + NL + "\t\t\t\t\t\treturn;" + NL + "\t\t\t\t\t}" + NL + "" + NL + "\t\t\t\t\tEntry diagramEntry = getDiagramResourceEntry(deltaVisitor.getMovedResourcesMap());" + NL + "\t\t\t\t\tif (diagramEntry != null) {" + NL + "\t\t\t\t\t\tdeltaVisitor.getMovedResourcesMap().remove(diagramEntry.getKey());" + NL + "\t\t\t\t\t\t// Setting new editor input since diagram file was" + NL + "\t\t\t\t\t\t// renamed Could be processed together with the rest of" + NL + "\t\t\t\t\t\t// moved resources if FileEditorInputProxy will wupport" + NL + "\t\t\t\t\t\t// IFileEditorInput substitution" + NL + "\t\t\t\t\t\thandleElementMoved(myInfo.getEditorInput(), (IPath) diagramEntry.getKey());" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\tif (deltaVisitor.getMovedResourcesMap().size() > 0) {" + NL + "\t\t\t\t\t\thandleResourcesMoved(deltaVisitor.getMovedResourcesMap());" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\tif (deltaVisitor.getChangedResources().size() > 0 || deltaVisitor.getMovedResourcesMap().size() > 0) {" + NL + "\t\t\t\t\t\t// reloading changed resources + changing URIs for moved" + NL + "\t\t\t\t\t\t// resources" + NL + "\t\t\t\t\t\thandleResourcesChanged(myInfo, deltaVisitor.getChangedResources(), null);" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\tif (deltaVisitor.getMovedResourcesMap().size() > 0) {" + NL + "\t\t\t\t\t\t// Marking whole ResourceSet as changed to preserve" + NL + "\t\t\t\t\t\t// changes in resource URIs made by" + NL + "\t\t\t\t\t\t// handleResourcesMoved() call" + NL + "\t\t\t\t\t\tmarkWholeResourceSetAsDirty(myInfo.getResourceSet());" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}" + NL + "\t\t\t});" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */\t" + NL + "\t\tprivate Entry getDiagramResourceEntry(Map movedResources) {" + NL + "\t\t\tfor (Iterator it = movedResources.entrySet().iterator(); it.hasNext();) {" + NL + "\t\t\t\tEntry nextEntry = (Entry) it.next();" + NL + "\t\t\t\tResource nextResource = (Resource) nextEntry.getValue();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null && file.equals(myInfo.getEditorInput().getFile())) {" + NL + "\t\t\t\t\treturn nextEntry;" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn null;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */\t" + NL + "\t\tprivate class ResourceDeltaVisitor implements IResourceDeltaVisitor {" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @generated" + NL + "\t\t\t */\t" + NL + "\t\t\tprivate Collection myChangedResources = new ArrayList();" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @generated" + NL + "\t\t\t */\t" + NL + "\t\t\tprivate Map myMovedResources = new HashMap();" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @generated" + NL + "\t\t\t */\t" + NL + "\t\t\tprivate Collection myDeletedResources = new ArrayList();" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * Can be called from any thread" + NL + "\t\t\t * @generated" + NL + "\t\t\t */\t" + NL + "\t\t\tpublic boolean visit(IResourceDelta delta) {" + NL + "\t\t\t\tif (delta.getFlags() != IResourceDelta.MARKERS && delta.getResource().getType() == IResource.FILE) {" + NL + "\t\t\t\t\tif ((delta.getKind() & (IResourceDelta.CHANGED | IResourceDelta.REMOVED)) != 0) {" + NL + "\t\t\t\t\t\tResource resource = myInfo.getResourceSet().getResource(URI.createURI(delta.getFullPath().toString()), false);" + NL + "\t\t\t\t\t\tif (resource != null && resource.isLoaded()) {" + NL + "\t\t\t\t\t\t\tsynchronized (myInfo) {" + NL + "\t\t\t\t\t\t\t\tif (myInfo.fCanBeSaved) {" + NL + "\t\t\t\t\t\t\t\t\tmyInfo.setUnSynchronized(resource);" + NL + "\t\t\t\t\t\t\t\t\treturn false;" + NL + "\t\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\tif ((delta.getKind() & IResourceDelta.REMOVED) != 0) {" + NL + "\t\t\t\t\t\t\t\t// element could be either moved/deleted or" + NL + "\t\t\t\t\t\t\t\t// changed." + NL + "\t\t\t\t\t\t\t\tif ((IResourceDelta.MOVED_TO & delta.getFlags()) != 0) {" + NL + "\t\t\t\t\t\t\t\t\tIPath destination = delta.getMovedToPath();" + NL + "\t\t\t\t\t\t\t\t\tmyMovedResources.put(destination, resource);" + NL + "\t\t\t\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\t\t\t\tmyDeletedResources.add(resource);" + NL + "\t\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\t\t\tmyChangedResources.add(resource);" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}" + NL + "" + NL + "\t\t\t\treturn true;" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @generated" + NL + "\t\t\t */\t" + NL + "\t\t\tpublic Collection getChangedResources() {" + NL + "\t\t\t\treturn myChangedResources;" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @generated" + NL + "\t\t\t */\t" + NL + "\t\t\tpublic Collection getDeletedResources() {" + NL + "\t\t\t\treturn myDeletedResources;" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @generated" + NL + "\t\t\t */\t" + NL + "\t\t\tpublic Map getMovedResourcesMap() {" + NL + "\t\t\t\treturn myMovedResources;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @generated" + NL + "\t */\t" + NL + "\tprivate class ResourceSetModificationListener extends EContentAdapter {" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */\t" + NL + "\t\tprivate NotificationFilter myModifiedFilter;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */\t" + NL + "\t\tprivate ResourceSetInfo myInfo;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */\t" + NL + "\t\tpublic ResourceSetModificationListener(ResourceSetInfo info) {" + NL + "\t\t\tmyInfo = info;" + NL + "\t\t\tmyModifiedFilter = NotificationFilter.createEventTypeFilter(Notification.SET).or(NotificationFilter.createEventTypeFilter(Notification.UNSET)).and(" + NL + "\t\t\t\t\tNotificationFilter.createFeatureFilter(Resource.class, Resource.RESOURCE__IS_MODIFIED));" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @generated" + NL + "\t\t */\t" + NL + "\t\tpublic void notifyChanged(Notification notification) {" + NL + "\t\t\tif (notification.getNotifier() instanceof ResourceSet) {" + NL + "\t\t\t\tsuper.notifyChanged(notification);" + NL + "\t\t\t}" + NL + "\t\t\tif (myModifiedFilter.matches(notification)) {" + NL + "\t\t\t\tif (notification.getNotifier() instanceof Resource) {" + NL + "\t\t\t\t\tResource resource = (Resource) notification.getNotifier();" + NL + "\t\t\t\t\tif (resource.isLoaded()) {" + NL + "\t\t\t\t\t\tboolean modified = false;" + NL + "\t\t\t\t\t\tfor (Iterator it = myInfo.getResourceSet().getResources().iterator(); it.hasNext() && !modified;) {" + NL + "\t\t\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\t\t\tif (nextResource.isLoaded()) {" + NL + "\t\t\t\t\t\t\t\tmodified = nextResource.isModified();" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\tboolean dirtyStateChanged = false;" + NL + "\t\t\t\t\t\tsynchronized (myInfo) {" + NL + "\t\t\t\t\t\t\tif (modified != myInfo.fCanBeSaved) {" + NL + "\t\t\t\t\t\t\t\tmyInfo.fCanBeSaved = modified;" + NL + "\t\t\t\t\t\t\t\tdirtyStateChanged = true;" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\tif (!resource.isModified()) {" + NL + "\t\t\t\t\t\t\t\tmyInfo.setSynchronized(resource);" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\tif (dirtyStateChanged) {" + NL + "\t\t\t\t\t\t\tfireElementDirtyStateChanged(myInfo.getEditorInput(), modified);" + NL + "\t\t\t\t\t\t\tif (!modified) {" + NL + "\t\t\t\t\t\t\t\tmyInfo.setModificationStamp(computeModificationStamp(myInfo));" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL;
  protected final String TEXT_12 = "\t\t\t\t\t}" + NL + "" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "}";
  protected final String TEXT_13 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
    
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];

    stringBuffer.append(TEXT_1);
    
String copyrightText = genDiagram.getEditorGen().getCopyrightText();
if (copyrightText != null && copyrightText.trim().length() > 0) {

    stringBuffer.append(TEXT_2);
    stringBuffer.append(copyrightText.replaceAll("\n", "\n *"));
    stringBuffer.append(TEXT_3);
    }
    importManager.emitPackageStatement(stringBuffer);
    stringBuffer.append(TEXT_4);
    importManager.addImport("org.eclipse.emf.ecore.EObject");
    importManager.addImport("java.io.IOException");
    importManager.addImport("java.util.ArrayList");
    importManager.addImport("java.util.Collection");
    importManager.addImport("java.util.Collections");
    importManager.addImport("java.util.HashMap");
    importManager.addImport("java.util.Iterator");
    importManager.addImport("java.util.Map");
    importManager.addImport("java.util.Map.Entry");
    importManager.addImport("org.eclipse.core.resources.IFile");
    importManager.addImport("org.eclipse.core.resources.IResource");
    importManager.addImport("org.eclipse.core.resources.IResourceChangeEvent");
    importManager.addImport("org.eclipse.core.resources.IResourceChangeListener");
    importManager.addImport("org.eclipse.core.resources.IResourceDelta");
    importManager.addImport("org.eclipse.core.resources.IResourceDeltaVisitor");
    importManager.addImport("org.eclipse.core.resources.IResourceStatus");
    importManager.addImport("org.eclipse.core.resources.IStorage");
    importManager.addImport("org.eclipse.core.resources.IWorkspace");
    importManager.addImport("org.eclipse.core.resources.ResourcesPlugin");
    importManager.addImport("org.eclipse.core.runtime.CoreException");
    importManager.addImport("org.eclipse.core.runtime.IPath");
    importManager.addImport("org.eclipse.core.runtime.IProgressMonitor");
    importManager.addImport("org.eclipse.core.runtime.IStatus");
    importManager.addImport("org.eclipse.core.runtime.Status");
    importManager.addImport("org.eclipse.core.runtime.jobs.ISchedulingRule");
    importManager.addImport("org.eclipse.core.runtime.jobs.MultiRule");
    importManager.addImport("org.eclipse.emf.common.notify.Notification");
    importManager.addImport("org.eclipse.emf.common.util.URI");
    importManager.addImport("org.eclipse.emf.ecore.resource.Resource");
    importManager.addImport("org.eclipse.emf.ecore.resource.ResourceSet");
    importManager.addImport("org.eclipse.emf.ecore.util.EContentAdapter");
    importManager.addImport("org.eclipse.emf.transaction.NotificationFilter");
    importManager.addImport("org.eclipse.emf.transaction.TransactionalEditingDomain");
    importManager.addImport("org.eclipse.emf.workspace.util.WorkspaceSynchronizer");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument");
    importManager.addImport("org.eclipse.gmf.runtime.notation.Diagram");
    importManager.addImport("org.eclipse.swt.widgets.Display");
    importManager.addImport("org.eclipse.ui.IEditorInput");
    importManager.addImport("org.eclipse.ui.IFileEditorInput");
    importManager.addImport("org.eclipse.ui.IStorageEditorInput");
    importManager.addImport("org.eclipse.ui.part.FileEditorInput");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.StorageDocumentProvider");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileEditorInputProxy");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.util.DiagramIOUtil");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.EditorStatusCodes");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocumentProvider");
    importManager.registerInnerClass("ResourceSetInfo");
    importManager.registerInnerClass("ResourceSetSynchronizer");
    importManager.registerInnerClass("ResourceSetModificationListener");
    importManager.markImportLocation(stringBuffer);
    stringBuffer.append(TEXT_5);
    stringBuffer.append(importManager.getCompilationUnitName());
    stringBuffer.append(TEXT_6);
    stringBuffer.append(importManager.getCompilationUnitName());
    stringBuffer.append(TEXT_7);
    stringBuffer.append(importManager.getCompilationUnitName());
    stringBuffer.append(TEXT_8);
    stringBuffer.append(importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName()));
    stringBuffer.append(TEXT_9);
    stringBuffer.append(importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName()));
    stringBuffer.append(TEXT_10);
    stringBuffer.append(importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName()));
    stringBuffer.append(TEXT_11);
    stringBuffer.append(TEXT_12);
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_13);
    return stringBuffer.toString();
  }
}
