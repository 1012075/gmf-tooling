/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Anna Karjakina (Borland) - initial API and implementation
 *    Artem Tikhomirov (Borland) - cleaned and simplified outcome
 */
 
import "http://www.eclipse.org/gmf/2007/GmfGraph/PropSheet";
import "http://www.eclipse.org/gmf/2006/GraphicalDefinition";
import "http://www.eclipse.org/gmf/2006/GenModel";
import "http://www.eclipse.org/emf/2002/GenModel";
import "http://www.eclipse.org/emf/2002/Ecore";

extension xpt::GenModelUtils;

boolean isPointTab(gmfgen::GenCustomPropertyTab tab) :
"points" == tab.iD
;

boolean isGeneratedTab(gmfgen::GenCustomPropertyTab tab) :
"genLayout" == tab.iD || "genStyles" == tab.iD
;

cached propsheet::FeatureReference getModelElement(propsheet::Group modelElementOwner) :
modelElementOwner.modelMediator
;

cached propsheet::FeatureReference getModelElement(propsheet::Radio modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::Checkbox modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::Spin modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::TextField modelElementOwner) :
modelElementOwner.modelElement
;

cached propsheet::FeatureReference getModelElement(propsheet::Sectionable modelElementOwner) :
null
;

cached String getQualifiedInterfaceName(genmodel::GenClassifier classifier) :
classifier.genPackage.basePackage+"."+classifier.genPackage.ecorePackage.name+(classifier.genPackage.interfacePackageSuffix != "" ? "."+classifier.genPackage.interfacePackageSuffix : "")+"."+getName(classifier)
;

cached String getQualifiedClassifierCreaterName(genmodel::GenClassifier classifier) :
classifier == null ? "null" : getQualifiedFactoryInterfaceName(classifier.genPackage) + ".eINSTANCE.create" + getName(classifier) + "()"
;

cached String getName(genmodel::GenClass genClass) :
getEClassifierName(genClass.ecoreClass)
;

cached String getName(genmodel::GenEnum enum) :
getEClassifierName(enum.ecoreEnum)
;

cached String getName(genmodel::GenDataType dataType) :
getEClassifierName(dataType.ecoreDataType)
;

cached String getName(genmodel::GenClassifier abstract) :
"AAA"+abstract.toString()+"AAA"
;

private cached String getName(genmodel::GenFeature genFeature) :
genFeature.ecoreFeature.name
;

private cached String getEClassifierName(ecore::EClassifier classifier) :
	switch (classifier.name) {
		case "Class" : "Class_"
		case "Name" : "Name_"
		default : classifier.name
	}
;

// TODO: completely rewrite this very bad-styled function!!!
cached String getSetterAccessor(genmodel::GenFeature feature) :
feature == null ? "" : (
let getAccessor = feature.getGetAccessor() :
getAccessor.startsWith("get|is") ? getAccessor.replaceFirst("get|is", "set") : "set" + feature.ecoreFeature.name.toFirstUpper()
)
;

// TODO: completely rewrite this very bad-styled function!!!
cached String getSetterAccessor(String getAccessor, String accessorName) :
getAccessor.replaceFirst("[.](get|is)" + accessorName + "[(][)]", ".set" + accessorName)
;

// TODO: add Java5 check: @see GenEnumLiteralImpl.getEnumLiteralInstanceConstantName()
cached String getEnumLiteralInstanceConstantName(genmodel::GenEnumLiteral genLiteral) :
genLiteral.getEnumLiteral().replaceAll(" ", "_").toUpperCase() + "_LITERAL"
;

cached propsheet::CustomPropertySection getCustomPropertySection(propsheet::Sectionable section) :
section.parent == null ? ((propsheet::CustomPropertySection) section) : getCustomPropertySection(section.parent)
;

boolean createLabel(propsheet::Labeled labeled) :
labeled.text != null ? labeled.text.createLabel : true
;

boolean isVisibleOnlyForTargets(propsheet::Group group) :
group.modelMediator != null ? group.modelMediator.visibleOnlyForTargets : false  
;

String name(propsheet::Sectionable section) :
section != null ? generateVarName(section) : ""  
;

// TODO: implement generation of variable names
private cached String generateVarName(propsheet::Sectionable section) :
((section.name == null || "" == section.name) && getModelElement(section) == null && getText(section) == null) ?
	"UnableToGenerateName" : composeVarName(section)
;

private cached propsheet::Text getText(propsheet::Sectionable section) :
null
;

private cached propsheet::Text getText(propsheet::Labeled section) :
section.text
;

private getTextValueForVar(propsheet::Text text) :
((String)text.overridedItemProviderText).replaceAll(" ", "")
;

private String composeVarName(propsheet::Sectionable section) :
	getVarPrefix()+buildMiddlePart(section)+getSectionableKindSuffix(section)
;

private String buildMiddlePart(propsheet::Sectionable section) :
	getMiddlePart(section).toFirstUpper().replaceAll("[ _]", "")
;

private String getMiddlePart(propsheet::Sectionable section) :
(section.name == null || "" == section.name || section.name.matches("^\\d+$")) ?
	(getModelElement(section) == null ? 
		(getText(section) == null ? 
			(section.name == null || "" == section.name ? "UnableToGenerateName" : section.name) : 
			getTextValueForVar(getText(section))) : 
		getModelElementNameForVar(getModelElement(section))) :
	section.name
;

private String getVarPrefix() : "my" ;

private cached String getSectionableKindSuffix(propsheet::Sectionable section) :
""
;

private cached String getSectionableKindSuffix(propsheet::Group section) :
createLabel(section) ? (isExpandable(section) ? "ExpandableComposite" : "Group") : "Composite"
;

private cached String getSectionableKindSuffix(propsheet::Radio section) :
"Radio"
;

private cached String getSectionableKindSuffix(propsheet::Checkbox section) :
"Checkbox"
;

private cached String getSectionableKindSuffix(propsheet::Spin section) :
"Spin"
;

private cached String getSectionableKindSuffix(propsheet::TextField section) :
"Text"
;

private cached String getSectionableKindSuffix(propsheet::Label section) :
"Label"
;

private cached String getModelElementNameForVar(propsheet::IsFeatureOfTypeReference featureRef) :
getName(featureRef.isOfType)
;

private cached String getModelElementNameForVar(propsheet::IsFeatureIsOfKindReference featureRef) :
	getVarName(featureRef.isOfValue.getEnumLiteral()).toFirstUpper()
;

private cached String getModelElementNameForVar(propsheet::ModelMediatorFeature featureRef) :
(featureRef.cast != null ? getName(featureRef.cast) : "") +
(featureRef.feature != null ? getVarName(getName(featureRef.feature)).toFirstUpper() : "")
;

private cached String getModelElementNameForVar(propsheet::FeatureReference featureRef) :
	getVarName(getName(featureRef.feature)).toFirstUpper()
;

private String getVarName(String originalName) :
	let x = getProcessedNames().select(n | originalName == n).size() :
		getProcessedNames().add(originalName) -> (x == 0 ? originalName : originalName + "$" + x)
;

private cached List[String] getProcessedNames() : {} ; 

cached String getFormattedName(genmodel::GenFeature genFeature) :
getName(genFeature) == null ? "" : format(getName(genFeature).toFirstUpper())
;

cached String getFormattedName(genmodel::GenClassifier genClassifier) :
getName(genClassifier) == null ? "" : format(getName(genClassifier))
;

//TODO: invoke CodeGenUtil.format(mixedCaseName, ' ', null, false, false), like GenFeatureImpl does 
private String format(String mixedCaseString) :
mixedCaseString
;

cached String getEnumLiteral(genmodel::GenEnumLiteral genLiteral) :
genLiteral.ecoreEnumLiteral.literal
;

cached String getEnumLiteralFriendlyName(genmodel::GenEnumLiteral genLiteral) :
getEnumLiteral(genLiteral).toLowerCase().toFirstUpper()
;

cached genmodel::GenClassifier getTarget(propsheet::Group group) :
group.getModelMediator().cast
;

cached List[propsheet::Group] collectAllParentGroups(propsheet::Sectionable section) :
section.parent == null ? {} : collectAllParentGroups(section.parent, {})
;

private cached List[propsheet::Group] collectAllParentGroups(propsheet::Group group, List[propsheet::Group] collected) :
group.parent == null ? collected : collectAllParentGroups(group.parent, collected).add(group)
;

cached propsheet::ModelMediatorFeature findModelMediator(propsheet::Group group) :
group.modelMediator == null ? (group.parent == null ? null : getModelMediator(group.parent)) : group.modelMediator
;

cached propsheet::ModelMediatorFeature getModelMediator(propsheet::Group group) :
group.modelMediator
;

cached genmodel::GenClassifier expectedType(propsheet::ModelMediatorFeature modelElement) :
modelElement.cast != null ? modelElement.cast : (modelElement.feature != null ? modelElement.feature.getTypeGenClassifier() : null)
;

cached genmodel::GenClassifier getTypeGenClassifier(genmodel::GenFeature genFeature) :
findGenClassifier(genFeature.genClass.genPackage.genModel, genFeature.ecoreFeature.eType)
;

cached String expectedTypeName(propsheet::ModelMediatorFeature modelElement) :
modelElement.expectedType() != null ? modelElement.expectedType().getQualifiedInterfaceName() : "/* XXX: Error: Useless ModelMediator with no feature or cast reference found*/ Object"
;

cached String expectedTypeVar(propsheet::ModelMediatorFeature modelElement) :
modelElement.expectedType() != null ? modelElement.expectedType().getName().toFirstLower() : "unknownTypeVar"
;

cached String castedVarCall(propsheet::ModelMediatorFeature modelElement, String elementName) :
modelElement.cast == null ? elementName : "(("+modelElement.cast.getQualifiedInterfaceName()+")"+elementName+")"
;

cached String castedVarFeatureCall(propsheet::ModelMediatorFeature modelElement, String varName) :
modelElement.castedVarCall(varName) + modelElement.addFeatureCall()
;

cached String addFeatureCall(propsheet::FeatureReference modelElement) :
modelElement.feature != null ? "."+modelElement.feature.getGetAccessor()+"()" : ""
;

boolean isExpandable(propsheet::Group group) :
group.expandable
;

boolean isNullCheck(propsheet::IsFeatureOfTypeReference ofType) :
ofType.feature == null && ofType.isOfType == null
;

boolean isNullCheck(propsheet::Reference ofType) :
false
;
